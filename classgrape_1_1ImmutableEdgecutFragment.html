<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libgrape-lite: grape::ImmutableEdgecutFragment&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libgrape-lite
   </div>
   <div id="projectbrief">A C++ library for parallel graph processing</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegrape.html">grape</a></li><li class="navelem"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">ImmutableEdgecutFragment</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classgrape_1_1ImmutableEdgecutFragment-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">grape::ImmutableEdgecutFragment&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A kind of edgecut fragment.  
 <a href="classgrape_1_1ImmutableEdgecutFragment.html#details">More...</a></p>

<p><code>#include &lt;immutable_edgecut_fragment.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for grape::ImmutableEdgecutFragment&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classgrape_1_1ImmutableEdgecutFragment.png" usemap="#grape::ImmutableEdgecutFragment_3C_20OID_5FT_2C_20VID_5FT_2C_20VDATA_5FT_2C_20EDATA_5FT_2C_20_5Fload_5Fstrategy_20_3E_map" alt=""/>
  <map id="grape::ImmutableEdgecutFragment_3C_20OID_5FT_2C_20VID_5FT_2C_20VDATA_5FT_2C_20EDATA_5FT_2C_20_5Fload_5Fstrategy_20_3E_map" name="grape::ImmutableEdgecutFragment_3C_20OID_5FT_2C_20VID_5FT_2C_20VDATA_5FT_2C_20EDATA_5FT_2C_20_5Fload_5Fstrategy_20_3E_map">
<area href="classgrape_1_1EdgecutFragmentBase.html" title="IEdgecutFragment defines the interfaces of fragments with edgecut. To learn more about edge-cut and v..." alt="grape::EdgecutFragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;" shape="rect" coords="0,56,532,80"/>
<area href="classgrape_1_1FragmentBase.html" title="FragmentBase is the base class for fragments. " alt="grape::FragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;" shape="rect" coords="0,0,532,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a45e2e4eae5807bc3172e77b8e4a7cd54"><td class="memItemLeft" align="right" valign="top"><a id="a45e2e4eae5807bc3172e77b8e4a7cd54"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>internal_vertex_t</b> = <a class="el" href="classgrape_1_1internal_1_1Vertex.html">internal::Vertex</a>&lt; VID_T, VDATA_T &gt;</td></tr>
<tr class="separator:a45e2e4eae5807bc3172e77b8e4a7cd54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d25d81593f9d4809e065455d5094059"><td class="memItemLeft" align="right" valign="top"><a id="a9d25d81593f9d4809e065455d5094059"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>edge_t</b> = <a class="el" href="classgrape_1_1Edge.html">Edge</a>&lt; VID_T, EDATA_T &gt;</td></tr>
<tr class="separator:a9d25d81593f9d4809e065455d5094059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ff0b07f6ab033ad9914ec525708add"><td class="memItemLeft" align="right" valign="top"><a id="aa5ff0b07f6ab033ad9914ec525708add"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>nbr_t</b> = <a class="el" href="structgrape_1_1Nbr.html">Nbr</a>&lt; VID_T, EDATA_T &gt;</td></tr>
<tr class="separator:aa5ff0b07f6ab033ad9914ec525708add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481ab7f89d1fc2ea34599281aba36d01"><td class="memItemLeft" align="right" valign="top"><a id="a481ab7f89d1fc2ea34599281aba36d01"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>vertex_t</b> = <a class="el" href="classgrape_1_1Vertex.html">Vertex</a>&lt; VID_T &gt;</td></tr>
<tr class="separator:a481ab7f89d1fc2ea34599281aba36d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af2e8e624ad90ad727605e3d2fed8ff"><td class="memItemLeft" align="right" valign="top"><a id="a6af2e8e624ad90ad727605e3d2fed8ff"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_adj_list_t</b> = <a class="el" href="classgrape_1_1ConstAdjList.html">ConstAdjList</a>&lt; VID_T, EDATA_T &gt;</td></tr>
<tr class="separator:a6af2e8e624ad90ad727605e3d2fed8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b24a799bcd6fc256cb085328bd8f27"><td class="memItemLeft" align="right" valign="top"><a id="a25b24a799bcd6fc256cb085328bd8f27"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>adj_list_t</b> = <a class="el" href="classgrape_1_1AdjList.html">AdjList</a>&lt; VID_T, EDATA_T &gt;</td></tr>
<tr class="separator:a25b24a799bcd6fc256cb085328bd8f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e356052d71a02c09f91bb4ccc7ed62"><td class="memItemLeft" align="right" valign="top"><a id="aa8e356052d71a02c09f91bb4ccc7ed62"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>vid_t</b> = VID_T</td></tr>
<tr class="separator:aa8e356052d71a02c09f91bb4ccc7ed62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d09cf1224889a67bf69e78ebef6f0d"><td class="memItemLeft" align="right" valign="top"><a id="a57d09cf1224889a67bf69e78ebef6f0d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>oid_t</b> = OID_T</td></tr>
<tr class="separator:a57d09cf1224889a67bf69e78ebef6f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad0919951a21fc596a410395fd65dd8"><td class="memItemLeft" align="right" valign="top"><a id="a7ad0919951a21fc596a410395fd65dd8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>vdata_t</b> = VDATA_T</td></tr>
<tr class="separator:a7ad0919951a21fc596a410395fd65dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40bc5a2714720b735c65614fcfce289"><td class="memItemLeft" align="right" valign="top"><a id="af40bc5a2714720b735c65614fcfce289"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>edata_t</b> = EDATA_T</td></tr>
<tr class="separator:af40bc5a2714720b735c65614fcfce289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4c353aabc8f600010f4d8c32cbd09f"><td class="memItemLeft" align="right" valign="top"><a id="a3d4c353aabc8f600010f4d8c32cbd09f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>vertex_map_t</b> = <a class="el" href="classgrape_1_1GlobalVertexMap.html">GlobalVertexMap</a>&lt; oid_t, vid_t &gt;</td></tr>
<tr class="separator:a3d4c353aabc8f600010f4d8c32cbd09f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a0056b21cca241c1b44cc3f888adb7"><td class="memItemLeft" align="right" valign="top"><a id="a16a0056b21cca241c1b44cc3f888adb7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>IsEdgeCut</b> = std::true_type</td></tr>
<tr class="separator:a16a0056b21cca241c1b44cc3f888adb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebfccb2bd88972d96243b935176a98e"><td class="memItemLeft" align="right" valign="top"><a id="a2ebfccb2bd88972d96243b935176a98e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>IsVertexCut</b> = std::false_type</td></tr>
<tr class="separator:a2ebfccb2bd88972d96243b935176a98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classgrape_1_1EdgecutFragmentBase"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classgrape_1_1EdgecutFragmentBase')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classgrape_1_1EdgecutFragmentBase.html">grape::EdgecutFragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a></td></tr>
<tr class="memitem:a875af7e1a0225ed6850acfd41c21b4c3 inherit pub_types_classgrape_1_1EdgecutFragmentBase"><td class="memItemLeft" align="right" valign="top"><a id="a875af7e1a0225ed6850acfd41c21b4c3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>vid_t</b> = VID_T</td></tr>
<tr class="separator:a875af7e1a0225ed6850acfd41c21b4c3 inherit pub_types_classgrape_1_1EdgecutFragmentBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68bc8778749aced35541e7c12bd2298 inherit pub_types_classgrape_1_1EdgecutFragmentBase"><td class="memItemLeft" align="right" valign="top"><a id="aa68bc8778749aced35541e7c12bd2298"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>vertex_t</b> = <a class="el" href="classgrape_1_1Vertex.html">Vertex</a>&lt; VID_T &gt;</td></tr>
<tr class="separator:aa68bc8778749aced35541e7c12bd2298 inherit pub_types_classgrape_1_1EdgecutFragmentBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a13e97a88de535f6ba3fda70714596364"><td class="memItemLeft" align="right" valign="top"><a id="a13e97a88de535f6ba3fda70714596364"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ImmutableEdgecutFragment</b> (std::shared_ptr&lt; <a class="el" href="classgrape_1_1GlobalVertexMap.html">vertex_map_t</a> &gt; vm_ptr)</td></tr>
<tr class="separator:a13e97a88de535f6ba3fda70714596364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5058da58eb7b233142745db5cf2379a"><td class="memItemLeft" align="right" valign="top"><a id="ad5058da58eb7b233142745db5cf2379a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Init</b> (fid_t <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a0afe2b478470b25b54536c8608df0729">fid</a>, std::vector&lt; <a class="el" href="classgrape_1_1internal_1_1Vertex.html">internal_vertex_t</a> &gt; &amp;vertices, std::vector&lt; <a class="el" href="classgrape_1_1Edge.html">edge_t</a> &gt; &amp;edges) override</td></tr>
<tr class="separator:ad5058da58eb7b233142745db5cf2379a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869cf37a8c0007ef0a9b40de2e787cd3"><td class="memTemplParams" colspan="2"><a id="a869cf37a8c0007ef0a9b40de2e787cd3"></a>
template&lt;typename IOADAPTOR_T &gt; </td></tr>
<tr class="memitem:a869cf37a8c0007ef0a9b40de2e787cd3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Serialize</b> (const std::string &amp;prefix)</td></tr>
<tr class="separator:a869cf37a8c0007ef0a9b40de2e787cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6f63771c338b5bc341c01ac654f02f"><td class="memTemplParams" colspan="2"><a id="a1a6f63771c338b5bc341c01ac654f02f"></a>
template&lt;typename IOADAPTOR_T &gt; </td></tr>
<tr class="memitem:a1a6f63771c338b5bc341c01ac654f02f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Deserialize</b> (const std::string &amp;prefix, const fid_t <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a0afe2b478470b25b54536c8608df0729">fid</a>)</td></tr>
<tr class="separator:a1a6f63771c338b5bc341c01ac654f02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fabcf0f1863bac47ea3629ffd4f26d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a7fabcf0f1863bac47ea3629ffd4f26d8">PrepareToRunApp</a> (<a class="el" href="namespacegrape.html#ad40e01301e786e48610a7570c132d93c">MessageStrategy</a> strategy, bool need_split_edges) override</td></tr>
<tr class="memdesc:a7fabcf0f1863bac47ea3629ffd4f26d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">For some kind of applications, specific data structures will be generated.  <a href="#a7fabcf0f1863bac47ea3629ffd4f26d8">More...</a><br /></td></tr>
<tr class="separator:a7fabcf0f1863bac47ea3629ffd4f26d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0afe2b478470b25b54536c8608df0729"><td class="memItemLeft" align="right" valign="top">fid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a0afe2b478470b25b54536c8608df0729">fid</a> () const override</td></tr>
<tr class="memdesc:a0afe2b478470b25b54536c8608df0729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ID of this fragment.  <a href="#a0afe2b478470b25b54536c8608df0729">More...</a><br /></td></tr>
<tr class="separator:a0afe2b478470b25b54536c8608df0729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64552ba12d0123acb3d4e2013b8f5124"><td class="memItemLeft" align="right" valign="top">fid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a64552ba12d0123acb3d4e2013b8f5124">fnum</a> () const override</td></tr>
<tr class="memdesc:a64552ba12d0123acb3d4e2013b8f5124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of fragments.  <a href="#a64552ba12d0123acb3d4e2013b8f5124">More...</a><br /></td></tr>
<tr class="separator:a64552ba12d0123acb3d4e2013b8f5124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8caee7f6dd7123923d1e35d717dba511"><td class="memItemLeft" align="right" valign="top"><a id="a8caee7f6dd7123923d1e35d717dba511"></a>
VID_T&#160;</td><td class="memItemRight" valign="bottom"><b>id_mask</b> () const</td></tr>
<tr class="separator:a8caee7f6dd7123923d1e35d717dba511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1e9999ffb4db95c219f12f237132e9"><td class="memItemLeft" align="right" valign="top"><a id="aaf1e9999ffb4db95c219f12f237132e9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>fid_offset</b> () const</td></tr>
<tr class="separator:aaf1e9999ffb4db95c219f12f237132e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5606f03c6fdfe66bc66648e29eb7b4"><td class="memItemLeft" align="right" valign="top"><a id="a8b5606f03c6fdfe66bc66648e29eb7b4"></a>
const vid_t *&#160;</td><td class="memItemRight" valign="bottom"><b>GetOuterVerticesGid</b> () const</td></tr>
<tr class="separator:a8b5606f03c6fdfe66bc66648e29eb7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab682def0de9c5354a03834f345d70e9c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#ab682def0de9c5354a03834f345d70e9c">GetEdgeNum</a> () const override</td></tr>
<tr class="memdesc:ab682def0de9c5354a03834f345d70e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of edges in this fragment.  <a href="#ab682def0de9c5354a03834f345d70e9c">More...</a><br /></td></tr>
<tr class="separator:ab682def0de9c5354a03834f345d70e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d0eb19b77e4797037d5dcdab20ebdd"><td class="memItemLeft" align="right" valign="top">VID_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#ad0d0eb19b77e4797037d5dcdab20ebdd">GetVerticesNum</a> () const override</td></tr>
<tr class="memdesc:ad0d0eb19b77e4797037d5dcdab20ebdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of vertices in this fragment.  <a href="#ad0d0eb19b77e4797037d5dcdab20ebdd">More...</a><br /></td></tr>
<tr class="separator:ad0d0eb19b77e4797037d5dcdab20ebdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa7bc4f49b82632ed7b55a09a668b0f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a5aa7bc4f49b82632ed7b55a09a668b0f">GetTotalVerticesNum</a> () const override</td></tr>
<tr class="memdesc:a5aa7bc4f49b82632ed7b55a09a668b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of vertices in the entire graph.  <a href="#a5aa7bc4f49b82632ed7b55a09a668b0f">More...</a><br /></td></tr>
<tr class="separator:a5aa7bc4f49b82632ed7b55a09a668b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba9ed08a9f7d854598be5f2fa00f762"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1VertexRange.html">VertexRange</a>&lt; VID_T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a0ba9ed08a9f7d854598be5f2fa00f762">Vertices</a> () const override</td></tr>
<tr class="memdesc:a0ba9ed08a9f7d854598be5f2fa00f762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all vertices referenced to this fragment.  <a href="#a0ba9ed08a9f7d854598be5f2fa00f762">More...</a><br /></td></tr>
<tr class="separator:a0ba9ed08a9f7d854598be5f2fa00f762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b817fed636e300dfdf35e8ca1add05b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1VertexRange.html">VertexRange</a>&lt; VID_T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a7b817fed636e300dfdf35e8ca1add05b">InnerVertices</a> () const override</td></tr>
<tr class="memdesc:a7b817fed636e300dfdf35e8ca1add05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vertex range of inner vertices in this fragment.  <a href="#a7b817fed636e300dfdf35e8ca1add05b">More...</a><br /></td></tr>
<tr class="separator:a7b817fed636e300dfdf35e8ca1add05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea82142c51e3091c841ee952f7bbb49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1VertexRange.html">VertexRange</a>&lt; VID_T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#adea82142c51e3091c841ee952f7bbb49">OuterVertices</a> () const override</td></tr>
<tr class="memdesc:adea82142c51e3091c841ee952f7bbb49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vertex range of outer vertices in this fragment.  <a href="#adea82142c51e3091c841ee952f7bbb49">More...</a><br /></td></tr>
<tr class="separator:adea82142c51e3091c841ee952f7bbb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f5009cd8ee7c04172dd1eb2b907d83"><td class="memItemLeft" align="right" valign="top"><a id="ac0f5009cd8ee7c04172dd1eb2b907d83"></a>
<a class="el" href="classgrape_1_1VertexRange.html">VertexRange</a>&lt; VID_T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>OuterVertices</b> (fid_t <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a0afe2b478470b25b54536c8608df0729">fid</a>) const</td></tr>
<tr class="separator:ac0f5009cd8ee7c04172dd1eb2b907d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f372d732d93789f99a3b7666a02c2f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#ad7f372d732d93789f99a3b7666a02c2f">GetVertex</a> (const OID_T &amp;oid, <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) const override</td></tr>
<tr class="memdesc:ad7f372d732d93789f99a3b7666a02c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a vertex with original ID vid.  <a href="#ad7f372d732d93789f99a3b7666a02c2f">More...</a><br /></td></tr>
<tr class="separator:ad7f372d732d93789f99a3b7666a02c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070cd2dfc9dfdf0ca9e54780b8a46ddf"><td class="memItemLeft" align="right" valign="top">OID_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a070cd2dfc9dfdf0ca9e54780b8a46ddf">GetId</a> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) const override</td></tr>
<tr class="memdesc:a070cd2dfc9dfdf0ca9e54780b8a46ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the original ID of a vertex.  <a href="#a070cd2dfc9dfdf0ca9e54780b8a46ddf">More...</a><br /></td></tr>
<tr class="separator:a070cd2dfc9dfdf0ca9e54780b8a46ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7d58b26b63c494551c0a80b0e5dc21"><td class="memItemLeft" align="right" valign="top">fid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a4f7d58b26b63c494551c0a80b0e5dc21">GetFragId</a> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;u) const override</td></tr>
<tr class="memdesc:a4f7d58b26b63c494551c0a80b0e5dc21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID of fragment the input vertex belongs to.  <a href="#a4f7d58b26b63c494551c0a80b0e5dc21">More...</a><br /></td></tr>
<tr class="separator:a4f7d58b26b63c494551c0a80b0e5dc21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c7c18c245d21d36a9fc4c056b364bc"><td class="memItemLeft" align="right" valign="top">const VDATA_T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a96c7c18c245d21d36a9fc4c056b364bc">GetData</a> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) const override</td></tr>
<tr class="memdesc:a96c7c18c245d21d36a9fc4c056b364bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data of a vertex.  <a href="#a96c7c18c245d21d36a9fc4c056b364bc">More...</a><br /></td></tr>
<tr class="separator:a96c7c18c245d21d36a9fc4c056b364bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec612a7f6f84edc98f339951c727679"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#aaec612a7f6f84edc98f339951c727679">SetData</a> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v, const VDATA_T &amp;val) override</td></tr>
<tr class="memdesc:aaec612a7f6f84edc98f339951c727679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the data of a vertex.  <a href="#aaec612a7f6f84edc98f339951c727679">More...</a><br /></td></tr>
<tr class="separator:aaec612a7f6f84edc98f339951c727679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec743ed18b9d7b4830f5278f723e029"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a2ec743ed18b9d7b4830f5278f723e029">HasChild</a> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) const override</td></tr>
<tr class="memdesc:a2ec743ed18b9d7b4830f5278f723e029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if vertex v has a child, that is, existing an edge v-&gt;u.  <a href="#a2ec743ed18b9d7b4830f5278f723e029">More...</a><br /></td></tr>
<tr class="separator:a2ec743ed18b9d7b4830f5278f723e029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d699ddc4ddd6673895c50a74919ad3e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a6d699ddc4ddd6673895c50a74919ad3e">HasParent</a> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) const override</td></tr>
<tr class="memdesc:a6d699ddc4ddd6673895c50a74919ad3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if vertex v has a parent, that is, existing an edge u-&gt;v.  <a href="#a6d699ddc4ddd6673895c50a74919ad3e">More...</a><br /></td></tr>
<tr class="separator:a6d699ddc4ddd6673895c50a74919ad3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff9acad12576aa2b5eba5cc56f7fb6b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a8ff9acad12576aa2b5eba5cc56f7fb6b">GetLocalOutDegree</a> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) const override</td></tr>
<tr class="memdesc:a8ff9acad12576aa2b5eba5cc56f7fb6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the out-degree of vertex v in this fragment.&lt;Paste&gt;  <a href="#a8ff9acad12576aa2b5eba5cc56f7fb6b">More...</a><br /></td></tr>
<tr class="separator:a8ff9acad12576aa2b5eba5cc56f7fb6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aee3bc87e4427a47e058b25cb94d831"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a5aee3bc87e4427a47e058b25cb94d831">GetLocalInDegree</a> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) const override</td></tr>
<tr class="memdesc:a5aee3bc87e4427a47e058b25cb94d831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the in-degree of vertex v in this fragment.  <a href="#a5aee3bc87e4427a47e058b25cb94d831">More...</a><br /></td></tr>
<tr class="separator:a5aee3bc87e4427a47e058b25cb94d831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba47337b7181f4a4eeffcef3be714f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#afba47337b7181f4a4eeffcef3be714f1">Gid2Vertex</a> (const VID_T &amp;gid, <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) const override</td></tr>
<tr class="memdesc:afba47337b7181f4a4eeffcef3be714f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from global id to a vertex handle.  <a href="#afba47337b7181f4a4eeffcef3be714f1">More...</a><br /></td></tr>
<tr class="separator:afba47337b7181f4a4eeffcef3be714f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc05d739f4abae69e0e2b0482f14b08"><td class="memItemLeft" align="right" valign="top">VID_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a7dc05d739f4abae69e0e2b0482f14b08">Vertex2Gid</a> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) const override</td></tr>
<tr class="memdesc:a7dc05d739f4abae69e0e2b0482f14b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from vertex handle to its global id.  <a href="#a7dc05d739f4abae69e0e2b0482f14b08">More...</a><br /></td></tr>
<tr class="separator:a7dc05d739f4abae69e0e2b0482f14b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3a46f8b8a6ea90fd8413c05cc595eb"><td class="memItemLeft" align="right" valign="top">VID_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a0c3a46f8b8a6ea90fd8413c05cc595eb">GetInnerVerticesNum</a> () const override</td></tr>
<tr class="memdesc:a0c3a46f8b8a6ea90fd8413c05cc595eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of inner vertices in this fragment.  <a href="#a0c3a46f8b8a6ea90fd8413c05cc595eb">More...</a><br /></td></tr>
<tr class="separator:a0c3a46f8b8a6ea90fd8413c05cc595eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b3286af10c79268f48daf770983449"><td class="memItemLeft" align="right" valign="top">VID_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a54b3286af10c79268f48daf770983449">GetOuterVerticesNum</a> () const override</td></tr>
<tr class="memdesc:a54b3286af10c79268f48daf770983449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of outer vertices in this fragment.  <a href="#a54b3286af10c79268f48daf770983449">More...</a><br /></td></tr>
<tr class="separator:a54b3286af10c79268f48daf770983449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234204d34e4bb4ab29db3e783cc6ca96"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a234204d34e4bb4ab29db3e783cc6ca96">IsInnerVertex</a> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) const override</td></tr>
<tr class="memdesc:a234204d34e4bb4ab29db3e783cc6ca96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if vertex v is inner vertex of this fragment.  <a href="#a234204d34e4bb4ab29db3e783cc6ca96">More...</a><br /></td></tr>
<tr class="separator:a234204d34e4bb4ab29db3e783cc6ca96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7756802feddc434b5cc859895fa8a8e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#ab7756802feddc434b5cc859895fa8a8e">IsOuterVertex</a> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) const override</td></tr>
<tr class="memdesc:ab7756802feddc434b5cc859895fa8a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if vertex v is outer vertex of this fragment.  <a href="#ab7756802feddc434b5cc859895fa8a8e">More...</a><br /></td></tr>
<tr class="separator:ab7756802feddc434b5cc859895fa8a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f125abc20c8a581940070ab90f53a95"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a7f125abc20c8a581940070ab90f53a95">GetInnerVertex</a> (const OID_T &amp;oid, <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) const override</td></tr>
<tr class="memdesc:a7f125abc20c8a581940070ab90f53a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a inner vertex with original ID vid.  <a href="#a7f125abc20c8a581940070ab90f53a95">More...</a><br /></td></tr>
<tr class="separator:a7f125abc20c8a581940070ab90f53a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c0bc09473e4b5290749fc924b29101"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#ae3c0bc09473e4b5290749fc924b29101">GetOuterVertex</a> (const OID_T &amp;oid, <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) const override</td></tr>
<tr class="memdesc:ae3c0bc09473e4b5290749fc924b29101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a outer vertex with original ID vid.  <a href="#ae3c0bc09473e4b5290749fc924b29101">More...</a><br /></td></tr>
<tr class="separator:ae3c0bc09473e4b5290749fc924b29101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a5ea4630ea95ac0d440920b4dd13c4"><td class="memItemLeft" align="right" valign="top">OID_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a08a5ea4630ea95ac0d440920b4dd13c4">GetInnerVertexId</a> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) const override</td></tr>
<tr class="memdesc:a08a5ea4630ea95ac0d440920b4dd13c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the original ID of an inner vertex.  <a href="#a08a5ea4630ea95ac0d440920b4dd13c4">More...</a><br /></td></tr>
<tr class="separator:a08a5ea4630ea95ac0d440920b4dd13c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cde42aeb70aacbd2be831abf67a4a7e"><td class="memItemLeft" align="right" valign="top">OID_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a5cde42aeb70aacbd2be831abf67a4a7e">GetOuterVertexId</a> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) const override</td></tr>
<tr class="memdesc:a5cde42aeb70aacbd2be831abf67a4a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the original ID of an outer vertex.  <a href="#a5cde42aeb70aacbd2be831abf67a4a7e">More...</a><br /></td></tr>
<tr class="separator:a5cde42aeb70aacbd2be831abf67a4a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f0ac1e38b4fb4dbcf89a84e18de2ab"><td class="memItemLeft" align="right" valign="top"><a id="aa4f0ac1e38b4fb4dbcf89a84e18de2ab"></a>
OID_T&#160;</td><td class="memItemRight" valign="bottom"><b>Gid2Oid</b> (const VID_T &amp;gid) const</td></tr>
<tr class="separator:aa4f0ac1e38b4fb4dbcf89a84e18de2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eecbc5e6a22366cc7e0612e6fd3c68e"><td class="memItemLeft" align="right" valign="top"><a id="a3eecbc5e6a22366cc7e0612e6fd3c68e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Oid2Gid</b> (const OID_T &amp;oid, VID_T &amp;gid) const</td></tr>
<tr class="separator:a3eecbc5e6a22366cc7e0612e6fd3c68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633fbc4c0141cf50c45e50ace496a330"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a633fbc4c0141cf50c45e50ace496a330">InnerVertexGid2Vertex</a> (const VID_T &amp;gid, <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) const override</td></tr>
<tr class="memdesc:a633fbc4c0141cf50c45e50ace496a330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from global id to an inner vertex handle.  <a href="#a633fbc4c0141cf50c45e50ace496a330">More...</a><br /></td></tr>
<tr class="separator:a633fbc4c0141cf50c45e50ace496a330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce3f1ebedef36bb59bc86b498eef757"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a9ce3f1ebedef36bb59bc86b498eef757">OuterVertexGid2Vertex</a> (const VID_T &amp;gid, <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) const override</td></tr>
<tr class="memdesc:a9ce3f1ebedef36bb59bc86b498eef757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from global id to an outer vertex handle.  <a href="#a9ce3f1ebedef36bb59bc86b498eef757">More...</a><br /></td></tr>
<tr class="separator:a9ce3f1ebedef36bb59bc86b498eef757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032adbbf34f92a49d8370b4e4d2bfce0"><td class="memItemLeft" align="right" valign="top">VID_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a032adbbf34f92a49d8370b4e4d2bfce0">GetOuterVertexGid</a> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) const override</td></tr>
<tr class="memdesc:a032adbbf34f92a49d8370b4e4d2bfce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from inner vertex handle to its global id.  <a href="#a032adbbf34f92a49d8370b4e4d2bfce0">More...</a><br /></td></tr>
<tr class="separator:a032adbbf34f92a49d8370b4e4d2bfce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4c75db4072c1e81be14584f373f08c"><td class="memItemLeft" align="right" valign="top">VID_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#ada4c75db4072c1e81be14584f373f08c">GetInnerVertexGid</a> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) const override</td></tr>
<tr class="memdesc:ada4c75db4072c1e81be14584f373f08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from outer vertex handle to its global id.  <a href="#ada4c75db4072c1e81be14584f373f08c">More...</a><br /></td></tr>
<tr class="separator:ada4c75db4072c1e81be14584f373f08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356f7be3210dd2f5c91d02b4fa01ec6a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a356f7be3210dd2f5c91d02b4fa01ec6a">IsIncomingBorderVertex</a> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) const</td></tr>
<tr class="memdesc:a356f7be3210dd2f5c91d02b4fa01ec6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if inner vertex v is an incoming border vertex, that is, existing edge u-&gt;v, u is an outer vertex.  <a href="#a356f7be3210dd2f5c91d02b4fa01ec6a">More...</a><br /></td></tr>
<tr class="separator:a356f7be3210dd2f5c91d02b4fa01ec6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7fac4408687a43bc911533f83a1a21c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#aa7fac4408687a43bc911533f83a1a21c">IsOutgoingBorderVertex</a> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) const</td></tr>
<tr class="memdesc:aa7fac4408687a43bc911533f83a1a21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if inner vertex v is an outgoing border vertex, that is, existing edge v-&gt;u, u is an outer vertex.  <a href="#aa7fac4408687a43bc911533f83a1a21c">More...</a><br /></td></tr>
<tr class="separator:aa7fac4408687a43bc911533f83a1a21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2518b51f952d37e7b75bee35e22e74f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a2518b51f952d37e7b75bee35e22e74f8">IsBorderVertex</a> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) const</td></tr>
<tr class="memdesc:a2518b51f952d37e7b75bee35e22e74f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if inner vertex v is an border vertex, that is, existing edge v-&gt;u or u-&gt;v, u is an outer vertex.  <a href="#a2518b51f952d37e7b75bee35e22e74f8">More...</a><br /></td></tr>
<tr class="separator:a2518b51f952d37e7b75bee35e22e74f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc52f4e68642a8d2d7e95ede3ef4dc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgrape_1_1DestList.html">DestList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#addc52f4e68642a8d2d7e95ede3ef4dc5">IEDests</a> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) const override</td></tr>
<tr class="memdesc:addc52f4e68642a8d2d7e95ede3ef4dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the incoming edge destination fragment ID list of a inner vertex.  <a href="#addc52f4e68642a8d2d7e95ede3ef4dc5">More...</a><br /></td></tr>
<tr class="separator:addc52f4e68642a8d2d7e95ede3ef4dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c14b60e8f5ef696af45964d94095fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgrape_1_1DestList.html">DestList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a37c14b60e8f5ef696af45964d94095fc">OEDests</a> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) const override</td></tr>
<tr class="memdesc:a37c14b60e8f5ef696af45964d94095fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the outgoing edge destination fragment ID list of a <a class="el" href="classgrape_1_1Vertex.html" title="A Vertex object only contains id of a vertex. It will be used when iterating vertices of a fragment a...">Vertex</a>.  <a href="#a37c14b60e8f5ef696af45964d94095fc">More...</a><br /></td></tr>
<tr class="separator:a37c14b60e8f5ef696af45964d94095fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a865db4254c297b2e110f60814bea4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgrape_1_1DestList.html">DestList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a10a865db4254c297b2e110f60814bea4">IOEDests</a> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) const override</td></tr>
<tr class="memdesc:a10a865db4254c297b2e110f60814bea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the edge destination fragment ID list of a inner vertex.  <a href="#a10a865db4254c297b2e110f60814bea4">More...</a><br /></td></tr>
<tr class="separator:a10a865db4254c297b2e110f60814bea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fbf53587916bd6d54264ffdd4b93948"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1AdjList.html">adj_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a8fbf53587916bd6d54264ffdd4b93948">GetIncomingAdjList</a> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) override</td></tr>
<tr class="memdesc:a8fbf53587916bd6d54264ffdd4b93948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the incoming adjacent vertices of v.  <a href="#a8fbf53587916bd6d54264ffdd4b93948">More...</a><br /></td></tr>
<tr class="separator:a8fbf53587916bd6d54264ffdd4b93948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789679de181f2b8674eb75a645fb0811"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1ConstAdjList.html">const_adj_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a789679de181f2b8674eb75a645fb0811">GetIncomingAdjList</a> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) const override</td></tr>
<tr class="memdesc:a789679de181f2b8674eb75a645fb0811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the incoming adjacent vertices of v.  <a href="#a789679de181f2b8674eb75a645fb0811">More...</a><br /></td></tr>
<tr class="separator:a789679de181f2b8674eb75a645fb0811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24157132aec0579aadc96c32cda710a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1AdjList.html">adj_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#ab24157132aec0579aadc96c32cda710a">GetOutgoingAdjList</a> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) override</td></tr>
<tr class="memdesc:ab24157132aec0579aadc96c32cda710a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the outgoing adjacent vertices of v.  <a href="#ab24157132aec0579aadc96c32cda710a">More...</a><br /></td></tr>
<tr class="separator:ab24157132aec0579aadc96c32cda710a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe09ed83548643fc35a953559f791fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1ConstAdjList.html">const_adj_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#aebe09ed83548643fc35a953559f791fc">GetOutgoingAdjList</a> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) const override</td></tr>
<tr class="memdesc:aebe09ed83548643fc35a953559f791fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the outgoing adjacent vertices of v.  <a href="#aebe09ed83548643fc35a953559f791fc">More...</a><br /></td></tr>
<tr class="separator:aebe09ed83548643fc35a953559f791fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa11eed231f1b98e3a8caa9f200e6610"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1AdjList.html">adj_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#aaa11eed231f1b98e3a8caa9f200e6610">GetIncomingInnerVertexAdjList</a> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) override</td></tr>
<tr class="memdesc:aaa11eed231f1b98e3a8caa9f200e6610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the incoming adjacent inner vertices of v.  <a href="#aaa11eed231f1b98e3a8caa9f200e6610">More...</a><br /></td></tr>
<tr class="separator:aaa11eed231f1b98e3a8caa9f200e6610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6f7e05200f65f17196fee203447c7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1ConstAdjList.html">const_adj_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#aec6f7e05200f65f17196fee203447c7d">GetIncomingInnerVertexAdjList</a> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) const override</td></tr>
<tr class="memdesc:aec6f7e05200f65f17196fee203447c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the incoming adjacent inner vertices of v.  <a href="#aec6f7e05200f65f17196fee203447c7d">More...</a><br /></td></tr>
<tr class="separator:aec6f7e05200f65f17196fee203447c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2879ecbc043252dc0d99c5b83ba3316c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1AdjList.html">adj_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a2879ecbc043252dc0d99c5b83ba3316c">GetIncomingOuterVertexAdjList</a> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) override</td></tr>
<tr class="memdesc:a2879ecbc043252dc0d99c5b83ba3316c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the incoming adjacent outer vertices of v.  <a href="#a2879ecbc043252dc0d99c5b83ba3316c">More...</a><br /></td></tr>
<tr class="separator:a2879ecbc043252dc0d99c5b83ba3316c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa437d499860a47cfd97b2474b1079d33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1ConstAdjList.html">const_adj_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#aa437d499860a47cfd97b2474b1079d33">GetIncomingOuterVertexAdjList</a> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) const override</td></tr>
<tr class="memdesc:aa437d499860a47cfd97b2474b1079d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the incoming adjacent outer vertices of v.  <a href="#aa437d499860a47cfd97b2474b1079d33">More...</a><br /></td></tr>
<tr class="separator:aa437d499860a47cfd97b2474b1079d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0ce243a06f7a08f2a58e4747f71003"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1AdjList.html">adj_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a4d0ce243a06f7a08f2a58e4747f71003">GetOutgoingInnerVertexAdjList</a> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) override</td></tr>
<tr class="memdesc:a4d0ce243a06f7a08f2a58e4747f71003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the outgoing adjacent inner vertices of v.  <a href="#a4d0ce243a06f7a08f2a58e4747f71003">More...</a><br /></td></tr>
<tr class="separator:a4d0ce243a06f7a08f2a58e4747f71003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1fc041d83623ee0e8af2276ee47d8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1ConstAdjList.html">const_adj_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a6e1fc041d83623ee0e8af2276ee47d8b">GetOutgoingInnerVertexAdjList</a> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) const override</td></tr>
<tr class="memdesc:a6e1fc041d83623ee0e8af2276ee47d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the outgoing adjacent inner vertices of v.  <a href="#a6e1fc041d83623ee0e8af2276ee47d8b">More...</a><br /></td></tr>
<tr class="separator:a6e1fc041d83623ee0e8af2276ee47d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae42b4233939f64c54b1b239a42f93bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1AdjList.html">adj_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#aae42b4233939f64c54b1b239a42f93bc">GetOutgoingOuterVertexAdjList</a> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) override</td></tr>
<tr class="memdesc:aae42b4233939f64c54b1b239a42f93bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the outgoing adjacent outer vertices of v.  <a href="#aae42b4233939f64c54b1b239a42f93bc">More...</a><br /></td></tr>
<tr class="separator:aae42b4233939f64c54b1b239a42f93bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673b7700cf45595363e633a6c5014cc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1ConstAdjList.html">const_adj_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a673b7700cf45595363e633a6c5014cc7">GetOutgoingOuterVertexAdjList</a> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v) const override</td></tr>
<tr class="memdesc:a673b7700cf45595363e633a6c5014cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the outgoing adjacent outer vertices of v.  <a href="#a673b7700cf45595363e633a6c5014cc7">More...</a><br /></td></tr>
<tr class="separator:a673b7700cf45595363e633a6c5014cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d2e6122516f8f0597cc96f2904ba8b4"><td class="memItemLeft" align="right" valign="top"><a id="a2d2e6122516f8f0597cc96f2904ba8b4"></a>
<a class="el" href="classgrape_1_1AdjList.html">adj_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetIncomingAdjList</b> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v, fid_t src_fid)</td></tr>
<tr class="separator:a2d2e6122516f8f0597cc96f2904ba8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0c65b0e6b41a19228f52b8756e091c"><td class="memItemLeft" align="right" valign="top"><a id="a5a0c65b0e6b41a19228f52b8756e091c"></a>
<a class="el" href="classgrape_1_1ConstAdjList.html">const_adj_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetIncomingAdjList</b> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v, fid_t src_fid) const</td></tr>
<tr class="separator:a5a0c65b0e6b41a19228f52b8756e091c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c27f61379fd7750a4bf268ce477e90a"><td class="memItemLeft" align="right" valign="top"><a id="a5c27f61379fd7750a4bf268ce477e90a"></a>
<a class="el" href="classgrape_1_1AdjList.html">adj_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetOutgoingAdjList</b> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v, fid_t dst_fid)</td></tr>
<tr class="separator:a5c27f61379fd7750a4bf268ce477e90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131e6c7ee1b4436e2206f4cc31f25467"><td class="memItemLeft" align="right" valign="top"><a id="a131e6c7ee1b4436e2206f4cc31f25467"></a>
<a class="el" href="classgrape_1_1ConstAdjList.html">const_adj_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetOutgoingAdjList</b> (const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;v, fid_t dst_fid) const</td></tr>
<tr class="separator:a131e6c7ee1b4436e2206f4cc31f25467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc23ec8999d401cc470c6f4081a824e"><td class="memItemLeft" align="right" valign="top"><a id="adcc23ec8999d401cc470c6f4081a824e"></a>
const std::vector&lt; <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>MirrorVertices</b> (fid_t <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a0afe2b478470b25b54536c8608df0729">fid</a>) const</td></tr>
<tr class="separator:adcc23ec8999d401cc470c6f4081a824e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750fe478f81e95c263f58a70544ce668"><td class="memItemLeft" align="right" valign="top"><a id="a750fe478f81e95c263f58a70544ce668"></a>
const <a class="el" href="classgrape_1_1VertexRange.html">VertexRange</a>&lt; VID_T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>MirrorsRange</b> (fid_t <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a0afe2b478470b25b54536c8608df0729">fid</a>) const</td></tr>
<tr class="separator:a750fe478f81e95c263f58a70544ce668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d20687f19d399564d4f99358a6137ad"><td class="memItemLeft" align="right" valign="top"><a id="a0d20687f19d399564d4f99358a6137ad"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetupMirrorInfo</b> (fid_t <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a0afe2b478470b25b54536c8608df0729">fid</a>, const <a class="el" href="classgrape_1_1VertexRange.html">VertexRange</a>&lt; VID_T &gt; &amp;range, const std::vector&lt; VID_T &gt; &amp;gid_list)</td></tr>
<tr class="separator:a0d20687f19d399564d4f99358a6137ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classgrape_1_1FragmentBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classgrape_1_1FragmentBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classgrape_1_1FragmentBase.html">grape::FragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a></td></tr>
<tr class="memitem:a6423ccb99076217f5c974fd79ea36e26 inherit pub_methods_classgrape_1_1FragmentBase"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1FragmentBase.html#a6423ccb99076217f5c974fd79ea36e26">Init</a> (fid_t <a class="el" href="classgrape_1_1FragmentBase.html#a7b444d5845efe40727adcf03fc615682">fid</a>, std::vector&lt; <a class="el" href="classgrape_1_1internal_1_1Vertex.html">internal::Vertex</a>&lt; VID_T, VDATA_T &gt;&gt; &amp;vertices, std::vector&lt; <a class="el" href="classgrape_1_1Edge.html">Edge</a>&lt; VID_T, EDATA_T &gt;&gt; &amp;edges)=0</td></tr>
<tr class="memdesc:a6423ccb99076217f5c974fd79ea36e26 inherit pub_methods_classgrape_1_1FragmentBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a fragment with a set of vertices and edges.  <a href="classgrape_1_1FragmentBase.html#a6423ccb99076217f5c974fd79ea36e26">More...</a><br /></td></tr>
<tr class="separator:a6423ccb99076217f5c974fd79ea36e26 inherit pub_methods_classgrape_1_1FragmentBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:adb68ae811c2a57064a1202e9239f9d61"><td class="memItemLeft" align="right" valign="top"><a id="adb68ae811c2a57064a1202e9239f9d61"></a>
static constexpr <a class="el" href="namespacegrape.html#ac82896434bbf475bc211722dc2257fbf">LoadStrategy</a>&#160;</td><td class="memItemRight" valign="bottom"><b>load_strategy</b> = _load_strategy</td></tr>
<tr class="separator:adb68ae811c2a57064a1202e9239f9d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aa2867fdd5fbb2c9e3e4961682f346807"><td class="memItemLeft" align="right" valign="top"><a id="aa2867fdd5fbb2c9e3e4961682f346807"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>initMessageDestination</b> (const <a class="el" href="namespacegrape.html#ad40e01301e786e48610a7570c132d93c">MessageStrategy</a> &amp;msg_strategy)</td></tr>
<tr class="separator:aa2867fdd5fbb2c9e3e4961682f346807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45846bea4079abd4cf1d9e5f6dc72546"><td class="memItemLeft" align="right" valign="top"><a id="a45846bea4079abd4cf1d9e5f6dc72546"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>initDestFidList</b> (bool in_edge, bool out_edge, <a class="el" href="classgrape_1_1Array.html">Array</a>&lt; fid_t, <a class="el" href="classgrape_1_1DefaultAllocator.html">Allocator</a>&lt; fid_t &gt;&gt; &amp;fid_list, <a class="el" href="classgrape_1_1Array.html">Array</a>&lt; fid_t *, <a class="el" href="classgrape_1_1DefaultAllocator.html">Allocator</a>&lt; fid_t *&gt;&gt; &amp;fid_list_offset)</td></tr>
<tr class="separator:a45846bea4079abd4cf1d9e5f6dc72546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1fe99713981f0ed7f84e4ba1487e5c"><td class="memItemLeft" align="right" valign="top"><a id="a1e1fe99713981f0ed7f84e4ba1487e5c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>initEdgesSplitter</b> (<a class="el" href="classgrape_1_1Array.html">Array</a>&lt; <a class="el" href="structgrape_1_1Nbr.html">nbr_t</a> *, <a class="el" href="classgrape_1_1DefaultAllocator.html">Allocator</a>&lt; <a class="el" href="structgrape_1_1Nbr.html">nbr_t</a> *&gt;&gt; &amp;eoffset, std::vector&lt; <a class="el" href="classgrape_1_1Array.html">Array</a>&lt; <a class="el" href="structgrape_1_1Nbr.html">nbr_t</a> *, <a class="el" href="classgrape_1_1DefaultAllocator.html">Allocator</a>&lt; <a class="el" href="structgrape_1_1Nbr.html">nbr_t</a> *&gt;&gt;&gt; &amp;espliters)</td></tr>
<tr class="separator:a1e1fe99713981f0ed7f84e4ba1487e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1c75aabb183ef27fa7332d51269b63"><td class="memItemLeft" align="right" valign="top"><a id="a8d1c75aabb183ef27fa7332d51269b63"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>initOuterVerticesOfFragment</b> ()</td></tr>
<tr class="separator:a8d1c75aabb183ef27fa7332d51269b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef089655b19b9d2e6c45fbdb85481766"><td class="memTemplParams" colspan="2"><a id="aef089655b19b9d2e6c45fbdb85481766"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aef089655b19b9d2e6c45fbdb85481766"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>calcFidBitWidth</b> (fid_t <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html#a64552ba12d0123acb3d4e2013b8f5124">fnum</a>, T &amp;id_mask, int &amp;fid_offset)</td></tr>
<tr class="separator:aef089655b19b9d2e6c45fbdb85481766"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aae34f2e2c84fb0f8135af7a3c5c14c59"><td class="memItemLeft" align="right" valign="top"><a id="aae34f2e2c84fb0f8135af7a3c5c14c59"></a>
std::shared_ptr&lt; <a class="el" href="classgrape_1_1GlobalVertexMap.html">vertex_map_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>vm_ptr_</b></td></tr>
<tr class="separator:aae34f2e2c84fb0f8135af7a3c5c14c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ddb42556ae5fcf3d5be60121e63414e"><td class="memItemLeft" align="right" valign="top"><a id="a2ddb42556ae5fcf3d5be60121e63414e"></a>
VID_T&#160;</td><td class="memItemRight" valign="bottom"><b>ivnum_</b></td></tr>
<tr class="separator:a2ddb42556ae5fcf3d5be60121e63414e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214ef171adff62b77b5be3efcb282a8f"><td class="memItemLeft" align="right" valign="top"><a id="a214ef171adff62b77b5be3efcb282a8f"></a>
VID_T&#160;</td><td class="memItemRight" valign="bottom"><b>ovnum_</b></td></tr>
<tr class="separator:a214ef171adff62b77b5be3efcb282a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82dfb47e32d3f17180b44c441f33acce"><td class="memItemLeft" align="right" valign="top"><a id="a82dfb47e32d3f17180b44c441f33acce"></a>
VID_T&#160;</td><td class="memItemRight" valign="bottom"><b>tvnum_</b></td></tr>
<tr class="separator:a82dfb47e32d3f17180b44c441f33acce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c742e2650775948be0c1befc01d97b"><td class="memItemLeft" align="right" valign="top"><a id="a05c742e2650775948be0c1befc01d97b"></a>
VID_T&#160;</td><td class="memItemRight" valign="bottom"><b>id_mask_</b></td></tr>
<tr class="separator:a05c742e2650775948be0c1befc01d97b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db64a7f6f6036b25bbb77916f63d20d"><td class="memItemLeft" align="right" valign="top"><a id="a7db64a7f6f6036b25bbb77916f63d20d"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ienum_</b> {}</td></tr>
<tr class="separator:a7db64a7f6f6036b25bbb77916f63d20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c21f2e61c92f6c4796eecfb368c4a8"><td class="memItemLeft" align="right" valign="top"><a id="a28c21f2e61c92f6c4796eecfb368c4a8"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>oenum_</b> {}</td></tr>
<tr class="separator:a28c21f2e61c92f6c4796eecfb368c4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b9eb006408e6c55d32a8aa6a04d3d6"><td class="memItemLeft" align="right" valign="top"><a id="a01b9eb006408e6c55d32a8aa6a04d3d6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>fid_offset_</b> {}</td></tr>
<tr class="separator:a01b9eb006408e6c55d32a8aa6a04d3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c3fcdda2c44c424494a305f17dbe78"><td class="memItemLeft" align="right" valign="top"><a id="af4c3fcdda2c44c424494a305f17dbe78"></a>
fid_t&#160;</td><td class="memItemRight" valign="bottom"><b>fid_</b> {}</td></tr>
<tr class="separator:af4c3fcdda2c44c424494a305f17dbe78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a115e30589757b64ff23e447c2d0f4e"><td class="memItemLeft" align="right" valign="top"><a id="a3a115e30589757b64ff23e447c2d0f4e"></a>
fid_t&#160;</td><td class="memItemRight" valign="bottom"><b>fnum_</b> {}</td></tr>
<tr class="separator:a3a115e30589757b64ff23e447c2d0f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774478c89f2be5e9baa3e53621f043d5"><td class="memItemLeft" align="right" valign="top"><a id="a774478c89f2be5e9baa3e53621f043d5"></a>
ska::flat_hash_map&lt; VID_T, VID_T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ovg2l_</b></td></tr>
<tr class="separator:a774478c89f2be5e9baa3e53621f043d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a618f037494985cb8c6fc1714868b35"><td class="memItemLeft" align="right" valign="top"><a id="a0a618f037494985cb8c6fc1714868b35"></a>
<a class="el" href="classgrape_1_1Array.html">Array</a>&lt; VID_T, <a class="el" href="classgrape_1_1DefaultAllocator.html">Allocator</a>&lt; VID_T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ovgid_</b></td></tr>
<tr class="separator:a0a618f037494985cb8c6fc1714868b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94651241cb5da912d2c966c104963c1"><td class="memItemLeft" align="right" valign="top"><a id="af94651241cb5da912d2c966c104963c1"></a>
<a class="el" href="classgrape_1_1Array.html">Array</a>&lt; <a class="el" href="structgrape_1_1Nbr.html">nbr_t</a>, <a class="el" href="classgrape_1_1DefaultAllocator.html">Allocator</a>&lt; <a class="el" href="structgrape_1_1Nbr.html">nbr_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ie_</b></td></tr>
<tr class="separator:af94651241cb5da912d2c966c104963c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf1c367cb4810db61a1ca67acdce9410"><td class="memItemLeft" align="right" valign="top"><a id="acf1c367cb4810db61a1ca67acdce9410"></a>
<a class="el" href="classgrape_1_1Array.html">Array</a>&lt; <a class="el" href="structgrape_1_1Nbr.html">nbr_t</a>, <a class="el" href="classgrape_1_1DefaultAllocator.html">Allocator</a>&lt; <a class="el" href="structgrape_1_1Nbr.html">nbr_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>oe_</b></td></tr>
<tr class="separator:acf1c367cb4810db61a1ca67acdce9410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaedf4a7f6e37e7b10837c4f3b257a91d"><td class="memItemLeft" align="right" valign="top"><a id="aaedf4a7f6e37e7b10837c4f3b257a91d"></a>
<a class="el" href="classgrape_1_1Array.html">Array</a>&lt; <a class="el" href="structgrape_1_1Nbr.html">nbr_t</a> *, <a class="el" href="classgrape_1_1DefaultAllocator.html">Allocator</a>&lt; <a class="el" href="structgrape_1_1Nbr.html">nbr_t</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ieoffset_</b></td></tr>
<tr class="separator:aaedf4a7f6e37e7b10837c4f3b257a91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e72caacf42e5783fcb48b3718b06138"><td class="memItemLeft" align="right" valign="top"><a id="a8e72caacf42e5783fcb48b3718b06138"></a>
<a class="el" href="classgrape_1_1Array.html">Array</a>&lt; <a class="el" href="structgrape_1_1Nbr.html">nbr_t</a> *, <a class="el" href="classgrape_1_1DefaultAllocator.html">Allocator</a>&lt; <a class="el" href="structgrape_1_1Nbr.html">nbr_t</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>oeoffset_</b></td></tr>
<tr class="separator:a8e72caacf42e5783fcb48b3718b06138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a69224f91665e599dbf532695d1125"><td class="memItemLeft" align="right" valign="top"><a id="a12a69224f91665e599dbf532695d1125"></a>
<a class="el" href="classgrape_1_1Array.html">Array</a>&lt; VDATA_T, <a class="el" href="classgrape_1_1DefaultAllocator.html">Allocator</a>&lt; VDATA_T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>vdata_</b></td></tr>
<tr class="separator:a12a69224f91665e599dbf532695d1125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c06aa4ea905a35f6ae46d14372ac7c"><td class="memItemLeft" align="right" valign="top"><a id="a42c06aa4ea905a35f6ae46d14372ac7c"></a>
std::vector&lt; <a class="el" href="classgrape_1_1VertexRange.html">VertexRange</a>&lt; VID_T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>outer_vertices_of_frag_</b></td></tr>
<tr class="separator:a42c06aa4ea905a35f6ae46d14372ac7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac222033c345b7dbf5ae9c3ea8a3d0b71"><td class="memItemLeft" align="right" valign="top"><a id="ac222033c345b7dbf5ae9c3ea8a3d0b71"></a>
std::vector&lt; <a class="el" href="classgrape_1_1VertexRange.html">VertexRange</a>&lt; VID_T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mirrors_range_</b></td></tr>
<tr class="separator:ac222033c345b7dbf5ae9c3ea8a3d0b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6cb22d8bd86ad456c2b1e1ba22427a9"><td class="memItemLeft" align="right" valign="top"><a id="af6cb22d8bd86ad456c2b1e1ba22427a9"></a>
std::vector&lt; std::vector&lt; <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mirrors_of_frag_</b></td></tr>
<tr class="separator:af6cb22d8bd86ad456c2b1e1ba22427a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab36853b6d40d5ad199d45d463054fc7"><td class="memItemLeft" align="right" valign="top"><a id="aab36853b6d40d5ad199d45d463054fc7"></a>
<a class="el" href="classgrape_1_1Array.html">Array</a>&lt; fid_t, <a class="el" href="classgrape_1_1DefaultAllocator.html">Allocator</a>&lt; fid_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>idst_</b></td></tr>
<tr class="separator:aab36853b6d40d5ad199d45d463054fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1a26277059072ebb367a3aee338864"><td class="memItemLeft" align="right" valign="top"><a id="a4f1a26277059072ebb367a3aee338864"></a>
<a class="el" href="classgrape_1_1Array.html">Array</a>&lt; fid_t, <a class="el" href="classgrape_1_1DefaultAllocator.html">Allocator</a>&lt; fid_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>odst_</b></td></tr>
<tr class="separator:a4f1a26277059072ebb367a3aee338864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3557367b4ab2cad3241ffd0961a971dd"><td class="memItemLeft" align="right" valign="top"><a id="a3557367b4ab2cad3241ffd0961a971dd"></a>
<a class="el" href="classgrape_1_1Array.html">Array</a>&lt; fid_t, <a class="el" href="classgrape_1_1DefaultAllocator.html">Allocator</a>&lt; fid_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iodst_</b></td></tr>
<tr class="separator:a3557367b4ab2cad3241ffd0961a971dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56c6a0b559a7edf4e5f0495d73e1cf4"><td class="memItemLeft" align="right" valign="top"><a id="ad56c6a0b559a7edf4e5f0495d73e1cf4"></a>
<a class="el" href="classgrape_1_1Array.html">Array</a>&lt; fid_t *, <a class="el" href="classgrape_1_1DefaultAllocator.html">Allocator</a>&lt; fid_t * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>idoffset_</b></td></tr>
<tr class="separator:ad56c6a0b559a7edf4e5f0495d73e1cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d314744dcbaad84c9382fd1af2d0af"><td class="memItemLeft" align="right" valign="top"><a id="af7d314744dcbaad84c9382fd1af2d0af"></a>
<a class="el" href="classgrape_1_1Array.html">Array</a>&lt; fid_t *, <a class="el" href="classgrape_1_1DefaultAllocator.html">Allocator</a>&lt; fid_t * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>odoffset_</b></td></tr>
<tr class="separator:af7d314744dcbaad84c9382fd1af2d0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc10345ca0be8c25f46a00026cffd296"><td class="memItemLeft" align="right" valign="top"><a id="adc10345ca0be8c25f46a00026cffd296"></a>
<a class="el" href="classgrape_1_1Array.html">Array</a>&lt; fid_t *, <a class="el" href="classgrape_1_1DefaultAllocator.html">Allocator</a>&lt; fid_t * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iodoffset_</b></td></tr>
<tr class="separator:adc10345ca0be8c25f46a00026cffd296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d9b4b739f86adbde61c794293a1fe9"><td class="memItemLeft" align="right" valign="top"><a id="af1d9b4b739f86adbde61c794293a1fe9"></a>
std::vector&lt; <a class="el" href="classgrape_1_1Array.html">Array</a>&lt; <a class="el" href="structgrape_1_1Nbr.html">nbr_t</a> *, <a class="el" href="classgrape_1_1DefaultAllocator.html">Allocator</a>&lt; <a class="el" href="structgrape_1_1Nbr.html">nbr_t</a> * &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iespliters_</b></td></tr>
<tr class="separator:af1d9b4b739f86adbde61c794293a1fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc1bf4df3d128f937aad3d57ae6de7b"><td class="memItemLeft" align="right" valign="top"><a id="adbc1bf4df3d128f937aad3d57ae6de7b"></a>
std::vector&lt; <a class="el" href="classgrape_1_1Array.html">Array</a>&lt; <a class="el" href="structgrape_1_1Nbr.html">nbr_t</a> *, <a class="el" href="classgrape_1_1DefaultAllocator.html">Allocator</a>&lt; <a class="el" href="structgrape_1_1Nbr.html">nbr_t</a> * &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>oespliters_</b></td></tr>
<tr class="separator:adbc1bf4df3d128f937aad3d57ae6de7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a373f01dd0caf9de74071f8d76b475a4d"><td class="memTemplParams" colspan="2"><a id="a373f01dd0caf9de74071f8d76b475a4d"></a>
template&lt;typename _FRAG_T , typename _PARTITIONER_T , typename _IOADAPTOR_T , typename _Enable &gt; </td></tr>
<tr class="memitem:a373f01dd0caf9de74071f8d76b475a4d"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>BasicFragmentLoader</b></td></tr>
<tr class="separator:a373f01dd0caf9de74071f8d76b475a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename OID_T, typename VID_T, typename VDATA_T, typename EDATA_T, LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt;<br />
class grape::ImmutableEdgecutFragment&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;</h3>

<p>A kind of edgecut fragment. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OID_T</td><td>Type of original ID. </td></tr>
    <tr><td class="paramname">VID_T</td><td>Type of global ID and local ID. </td></tr>
    <tr><td class="paramname">VDATA_T</td><td>Type of data on vertices. </td></tr>
    <tr><td class="paramname">EDATA_T</td><td>Type of data on edges. </td></tr>
    <tr><td class="paramname">LoadStrategy</td><td>The strategy to store adjacency information, default is only_out.</td></tr>
  </table>
  </dd>
</dl>
<p>With an edgecut partition, each vertex is assigned to a fragment. In a fragment, inner vertices are those vertices assigned to it, and the outer vertices are the remaining vertices adjacent to some of the inner vertices. The load strategy defines how to store the adjacency between inner and outer vertices.</p>
<p>For example, a graph G = {V, E} V = {v0, v1, v2, v3, v4} E = {(v0, v2), (v0, v3), (v1, v0), (v3, v1), (v3, v4), (v4, v1), (v4, v2)}</p>
<p>Subset V_0 = {v0, v1} is assigned to fragment_0, so InnerVertices_0 = {v0, v1}</p>
<p>If the load strategy is kOnlyIn: All incoming edges (along with the source vertices) of inner vertices will be stored in a fragment. So, OuterVertices_0 = {v3, v4}, E_0 = {(v1, v0), (v3, v1), (v4, v1)}</p>
<p>If the load strategy is kOnlyOut: All outgoing edges (along with the destination vertices) of inner vertices will be stored in a fragment. So, OuterVertices_0 = {v2, v3}, E_0 = {(v0, v2), (v0, v3), (v1, v0)}</p>
<p>If the load strategy is kBothOutIn: All incoming edges (along with the source vertices) and outgoing edges (along with destination vertices) of inner vertices will be stored in a fragment. So, OuterVertices_0 = {v2, v3, v4}, E_0 = {(v0, v2), (v0, v3), (v1, v0), (v3, v1), (v4, v1), (v4, v2)}</p>
<p>Inner vertices and outer vertices of a fragment will be given a local ID {0, 1, ..., ivnum - 1, ivnum, ..., ivnum + ovnum - 1}, then iterate on vertices can be implemented to increment the local ID. Also, the sets of inner vertices, outer vertices and all vertices are ranges of local ID. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a0afe2b478470b25b54536c8608df0729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0afe2b478470b25b54536c8608df0729">&#9670;&nbsp;</a></span>fid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">fid_t <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::fid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the ID of this fragment. </p>
<dl class="section return"><dt>Returns</dt><dd>The ID of this fragment. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1FragmentBase.html#a7b444d5845efe40727adcf03fc615682">grape::FragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="a64552ba12d0123acb3d4e2013b8f5124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64552ba12d0123acb3d4e2013b8f5124">&#9670;&nbsp;</a></span>fnum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">fid_t <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::fnum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of fragments. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of fragments. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1FragmentBase.html#ae57aadd7cb639f4cd0d741a3e1937676">grape::FragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="a96c7c18c245d21d36a9fc4c056b364bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c7c18c245d21d36a9fc4c056b364bc">&#9670;&nbsp;</a></span>GetData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const VDATA_T&amp; <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::GetData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the data of a vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Data on it. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1FragmentBase.html#a29aa438e2cb566a334cede8db48c225a">grape::FragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="ab682def0de9c5354a03834f345d70e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab682def0de9c5354a03834f345d70e9c">&#9670;&nbsp;</a></span>GetEdgeNum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::GetEdgeNum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of edges in this fragment. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of edges in this fragment. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1FragmentBase.html#ad89174950576a5013099070605c4406e">grape::FragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="a4f7d58b26b63c494551c0a80b0e5dc21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f7d58b26b63c494551c0a80b0e5dc21">&#9670;&nbsp;</a></span>GetFragId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">fid_t <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::GetFragId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ID of fragment the input vertex belongs to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Input vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Its fragment ID. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1FragmentBase.html#a6b31132906bfc1a006e5fa9d8fb4077f">grape::FragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="a070cd2dfc9dfdf0ca9e54780b8a46ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070cd2dfc9dfdf0ca9e54780b8a46ddf">&#9670;&nbsp;</a></span>GetId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OID_T <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::GetId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the original ID of a vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Its original ID. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1FragmentBase.html#a3382cebdbb88cc91bcd8df834fe3dc6f">grape::FragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="a8fbf53587916bd6d54264ffdd4b93948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fbf53587916bd6d54264ffdd4b93948">&#9670;&nbsp;</a></span>GetIncomingAdjList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgrape_1_1AdjList.html">adj_list_t</a> <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::GetIncomingAdjList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the incoming adjacent vertices of v. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The incoming adjacent vertices of v.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Only inner vertex is available. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1FragmentBase.html#ab49fba1126fb9829676d57e78e2c4f67">grape::FragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="a789679de181f2b8674eb75a645fb0811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a789679de181f2b8674eb75a645fb0811">&#9670;&nbsp;</a></span>GetIncomingAdjList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgrape_1_1ConstAdjList.html">const_adj_list_t</a> <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::GetIncomingAdjList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the incoming adjacent vertices of v. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The incoming adjacent vertices of v.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Only inner vertex is available. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1FragmentBase.html">grape::FragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="aaa11eed231f1b98e3a8caa9f200e6610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa11eed231f1b98e3a8caa9f200e6610">&#9670;&nbsp;</a></span>GetIncomingInnerVertexAdjList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgrape_1_1AdjList.html">adj_list_t</a> <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::GetIncomingInnerVertexAdjList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the incoming adjacent inner vertices of v. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The incoming adjacent inner vertices of v.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>This method is available only when need_split_edges set in application's specification. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1EdgecutFragmentBase.html#aa85c9ca0ccf6765637fbaefef036418b">grape::EdgecutFragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="aec6f7e05200f65f17196fee203447c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6f7e05200f65f17196fee203447c7d">&#9670;&nbsp;</a></span>GetIncomingInnerVertexAdjList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgrape_1_1ConstAdjList.html">const_adj_list_t</a> <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::GetIncomingInnerVertexAdjList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the incoming adjacent inner vertices of v. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The incoming adjacent inner vertices of v.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>This method is available only when need_split_edges set in application's specification. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1EdgecutFragmentBase.html#a02bdab944cae288a5839c949f3744dc5">grape::EdgecutFragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="a2879ecbc043252dc0d99c5b83ba3316c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2879ecbc043252dc0d99c5b83ba3316c">&#9670;&nbsp;</a></span>GetIncomingOuterVertexAdjList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgrape_1_1AdjList.html">adj_list_t</a> <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::GetIncomingOuterVertexAdjList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the incoming adjacent outer vertices of v. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The incoming adjacent outer vertices of v.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>This method is available only when need_split_edges set in application's specification. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1EdgecutFragmentBase.html#ae99f778b1bb95702c82441f60496900c">grape::EdgecutFragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="aa437d499860a47cfd97b2474b1079d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa437d499860a47cfd97b2474b1079d33">&#9670;&nbsp;</a></span>GetIncomingOuterVertexAdjList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgrape_1_1ConstAdjList.html">const_adj_list_t</a> <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::GetIncomingOuterVertexAdjList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the incoming adjacent outer vertices of v. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The incoming adjacent outer vertices of v.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>This method is available only when need_split_edges set in application's specification. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1EdgecutFragmentBase.html#ae7d2571f80ea5bcf59a0ba178dc39f5c">grape::EdgecutFragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="a7f125abc20c8a581940070ab90f53a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f125abc20c8a581940070ab90f53a95">&#9670;&nbsp;</a></span>GetInnerVertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::GetInnerVertex </td>
          <td>(</td>
          <td class="paramtype">const OID_T &amp;&#160;</td>
          <td class="paramname"><em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a inner vertex with original ID vid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vid</td><td>Original ID. </td></tr>
    <tr><td class="paramname">v</td><td>Got vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if find a inner vertex with original ID vid in this fragment, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1EdgecutFragmentBase.html#a248fff432314c0ddde84850128e1822e">grape::EdgecutFragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="ada4c75db4072c1e81be14584f373f08c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada4c75db4072c1e81be14584f373f08c">&#9670;&nbsp;</a></span>GetInnerVertexGid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VID_T <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::GetInnerVertexGid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert from outer vertex handle to its global id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vertex handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Global id of the vertex. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1EdgecutFragmentBase.html#ae3904f20e529730ea19758da806f78b5">grape::EdgecutFragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="a08a5ea4630ea95ac0d440920b4dd13c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a5ea4630ea95ac0d440920b4dd13c4">&#9670;&nbsp;</a></span>GetInnerVertexId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OID_T <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::GetInnerVertexId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the original ID of an inner vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original ID. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1EdgecutFragmentBase.html#a36fda6d46eccfb21bc842c915f022188">grape::EdgecutFragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="a0c3a46f8b8a6ea90fd8413c05cc595eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c3a46f8b8a6ea90fd8413c05cc595eb">&#9670;&nbsp;</a></span>GetInnerVerticesNum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VID_T <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::GetInnerVerticesNum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of inner vertices in this fragment. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of inner vertices in this fragment. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1EdgecutFragmentBase.html#a70cce9c699cd194dae3aec93f6159e54">grape::EdgecutFragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="a5aee3bc87e4427a47e058b25cb94d831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aee3bc87e4427a47e058b25cb94d831">&#9670;&nbsp;</a></span>GetLocalInDegree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::GetLocalInDegree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the in-degree of vertex v in this fragment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>In-degree of vertex v in this fragment. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1FragmentBase.html#aa172279ce732d28e1cb961ecbc361217">grape::FragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="a8ff9acad12576aa2b5eba5cc56f7fb6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff9acad12576aa2b5eba5cc56f7fb6b">&#9670;&nbsp;</a></span>GetLocalOutDegree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::GetLocalOutDegree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the out-degree of vertex v in this fragment.&lt;Paste&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Out-degree of vertex v in this fragment. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1FragmentBase.html#a36d6624c65d8e039f515e9aa8b65d15b">grape::FragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="ae3c0bc09473e4b5290749fc924b29101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c0bc09473e4b5290749fc924b29101">&#9670;&nbsp;</a></span>GetOuterVertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::GetOuterVertex </td>
          <td>(</td>
          <td class="paramtype">const OID_T &amp;&#160;</td>
          <td class="paramname"><em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a outer vertex with original ID vid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vid</td><td>Original ID. </td></tr>
    <tr><td class="paramname">v</td><td>Got vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if find a outer vertex with original ID vid in this fragment, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1EdgecutFragmentBase.html#a1ef0aabb68e62e732617f635fa806e30">grape::EdgecutFragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="a032adbbf34f92a49d8370b4e4d2bfce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032adbbf34f92a49d8370b4e4d2bfce0">&#9670;&nbsp;</a></span>GetOuterVertexGid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VID_T <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::GetOuterVertexGid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert from inner vertex handle to its global id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vertex handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Global id of the vertex. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1EdgecutFragmentBase.html#ae8923c4e2f9f0ffd429b662d5ca760c8">grape::EdgecutFragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="a5cde42aeb70aacbd2be831abf67a4a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cde42aeb70aacbd2be831abf67a4a7e">&#9670;&nbsp;</a></span>GetOuterVertexId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OID_T <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::GetOuterVertexId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the original ID of an outer vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original ID. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1EdgecutFragmentBase.html#af2d446680b98853daef04ad4d2dbe471">grape::EdgecutFragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="a54b3286af10c79268f48daf770983449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b3286af10c79268f48daf770983449">&#9670;&nbsp;</a></span>GetOuterVerticesNum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VID_T <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::GetOuterVerticesNum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of outer vertices in this fragment. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of outer vertices in this fragment. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1EdgecutFragmentBase.html#aed97cb85bd3f15aa31c9fd5984f674c5">grape::EdgecutFragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="ab24157132aec0579aadc96c32cda710a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24157132aec0579aadc96c32cda710a">&#9670;&nbsp;</a></span>GetOutgoingAdjList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgrape_1_1AdjList.html">adj_list_t</a> <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::GetOutgoingAdjList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the outgoing adjacent vertices of v. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The outgoing adjacent vertices of v.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Only inner vertex is available. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1FragmentBase.html#a13c0656b67f896fcbdbd80199b566f7d">grape::FragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="aebe09ed83548643fc35a953559f791fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe09ed83548643fc35a953559f791fc">&#9670;&nbsp;</a></span>GetOutgoingAdjList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgrape_1_1ConstAdjList.html">const_adj_list_t</a> <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::GetOutgoingAdjList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the outgoing adjacent vertices of v. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The outgoing adjacent vertices of v.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Only inner vertex is available. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1FragmentBase.html">grape::FragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="a4d0ce243a06f7a08f2a58e4747f71003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d0ce243a06f7a08f2a58e4747f71003">&#9670;&nbsp;</a></span>GetOutgoingInnerVertexAdjList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgrape_1_1AdjList.html">adj_list_t</a> <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::GetOutgoingInnerVertexAdjList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the outgoing adjacent inner vertices of v. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The outgoing adjacent inner vertices of v.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>This method is available only when need_split_edges set in application's specification. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1EdgecutFragmentBase.html#a225bf6bdcb36a49a73604f0e31f0a04c">grape::EdgecutFragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="a6e1fc041d83623ee0e8af2276ee47d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e1fc041d83623ee0e8af2276ee47d8b">&#9670;&nbsp;</a></span>GetOutgoingInnerVertexAdjList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgrape_1_1ConstAdjList.html">const_adj_list_t</a> <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::GetOutgoingInnerVertexAdjList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the outgoing adjacent inner vertices of v. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The outgoing adjacent inner vertices of v.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>This method is available only when need_split_edges set in application's specification. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1EdgecutFragmentBase.html#a33c0e007574f859b5b12d0eefbf21eb8">grape::EdgecutFragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="aae42b4233939f64c54b1b239a42f93bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae42b4233939f64c54b1b239a42f93bc">&#9670;&nbsp;</a></span>GetOutgoingOuterVertexAdjList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgrape_1_1AdjList.html">adj_list_t</a> <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::GetOutgoingOuterVertexAdjList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the outgoing adjacent outer vertices of v. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The outgoing adjacent outer vertices of v.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>This method is available only when need_split_edges set in application's specification. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1EdgecutFragmentBase.html#a3bd96654dc51610be15409021b07a334">grape::EdgecutFragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="a673b7700cf45595363e633a6c5014cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a673b7700cf45595363e633a6c5014cc7">&#9670;&nbsp;</a></span>GetOutgoingOuterVertexAdjList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgrape_1_1ConstAdjList.html">const_adj_list_t</a> <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::GetOutgoingOuterVertexAdjList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the outgoing adjacent outer vertices of v. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The outgoing adjacent outer vertices of v.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>This method is available only when need_split_edges set in application's specification. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1EdgecutFragmentBase.html#ae2a66e86e377fa5f7803ba22a72bd7fb">grape::EdgecutFragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="a5aa7bc4f49b82632ed7b55a09a668b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa7bc4f49b82632ed7b55a09a668b0f">&#9670;&nbsp;</a></span>GetTotalVerticesNum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::GetTotalVerticesNum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of vertices in the entire graph. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of vertices in the entire graph. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1FragmentBase.html#a6aa7ebc7b95bf37e3a66b131738d38b2">grape::FragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="ad7f372d732d93789f99a3b7666a02c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f372d732d93789f99a3b7666a02c2f">&#9670;&nbsp;</a></span>GetVertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::GetVertex </td>
          <td>(</td>
          <td class="paramtype">const OID_T &amp;&#160;</td>
          <td class="paramname"><em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a vertex with original ID vid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vid</td><td>Original ID. </td></tr>
    <tr><td class="paramname">v</td><td>Got vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If find the vertex in this fragment, return true. Otherwise, return false. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1FragmentBase.html#a1f355a5d021396b76e610ef7eade9412">grape::FragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="ad0d0eb19b77e4797037d5dcdab20ebdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0d0eb19b77e4797037d5dcdab20ebdd">&#9670;&nbsp;</a></span>GetVerticesNum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VID_T <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::GetVerticesNum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of vertices in this fragment. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of vertices in this fragment. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1FragmentBase.html#ab3c50ea5e9786cc471f1de707b9c3f3d">grape::FragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="afba47337b7181f4a4eeffcef3be714f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afba47337b7181f4a4eeffcef3be714f1">&#9670;&nbsp;</a></span>Gid2Vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::Gid2Vertex </td>
          <td>(</td>
          <td class="paramtype">const VID_T &amp;&#160;</td>
          <td class="paramname"><em>gid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert from global id to a vertex handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gid</td><td>Input global id. </td></tr>
    <tr><td class="paramname">v</td><td>Output vertex handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if exists a vertex with global id as gid in this fragment, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1FragmentBase.html#acd6fcafd81c5ad82574bd6e3ef612e17">grape::FragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="a2ec743ed18b9d7b4830f5278f723e029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec743ed18b9d7b4830f5278f723e029">&#9670;&nbsp;</a></span>HasChild()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::HasChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if vertex v has a child, that is, existing an edge v-&gt;u. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if vertex v has a child, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1FragmentBase.html#a8453a481e198daf1469cd73c9fcce90d">grape::FragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="a6d699ddc4ddd6673895c50a74919ad3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d699ddc4ddd6673895c50a74919ad3e">&#9670;&nbsp;</a></span>HasParent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::HasParent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if vertex v has a parent, that is, existing an edge u-&gt;v. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if vertex v has a parent, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1FragmentBase.html#ad9735e6e575c30ff2dab4d7d0b540858">grape::FragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="addc52f4e68642a8d2d7e95ede3ef4dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addc52f4e68642a8d2d7e95ede3ef4dc5">&#9670;&nbsp;</a></span>IEDests()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgrape_1_1DestList.html">DestList</a> <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::IEDests </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the incoming edge destination fragment ID list of a inner vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The incoming edge destination fragment ID list.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>This method is only available when application set message strategy as kAlongIncomingEdgeToOuterVertex. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1EdgecutFragmentBase.html#ad49e2642b71a4c54b4c300969a8fbeb7">grape::EdgecutFragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="a633fbc4c0141cf50c45e50ace496a330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a633fbc4c0141cf50c45e50ace496a330">&#9670;&nbsp;</a></span>InnerVertexGid2Vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::InnerVertexGid2Vertex </td>
          <td>(</td>
          <td class="paramtype">const VID_T &amp;&#160;</td>
          <td class="paramname"><em>gid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert from global id to an inner vertex handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gid</td><td>Input global id. </td></tr>
    <tr><td class="paramname">v</td><td>Output vertex handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if exists an inner vertex of this fragment with global id as gid, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1EdgecutFragmentBase.html#a184a56fd97fd810bbc60d3c93ff69f92">grape::EdgecutFragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="a7b817fed636e300dfdf35e8ca1add05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b817fed636e300dfdf35e8ca1add05b">&#9670;&nbsp;</a></span>InnerVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgrape_1_1VertexRange.html">VertexRange</a>&lt;VID_T&gt; <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::InnerVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the vertex range of inner vertices in this fragment. </p>
<dl class="section return"><dt>Returns</dt><dd>The vertex range of inner vertices in this fragment. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1EdgecutFragmentBase.html#ac01fdfe647fb3642a98d70f9a0c12b9c">grape::EdgecutFragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="a10a865db4254c297b2e110f60814bea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a865db4254c297b2e110f60814bea4">&#9670;&nbsp;</a></span>IOEDests()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgrape_1_1DestList.html">DestList</a> <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::IOEDests </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the edge destination fragment ID list of a inner vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The edge destination fragment ID list.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>This method is only available when application set message strategy as kAlongedge_toOuterVertex. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1EdgecutFragmentBase.html#ab2470c1f5fb4545d3d1520d348564e63">grape::EdgecutFragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="a2518b51f952d37e7b75bee35e22e74f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2518b51f952d37e7b75bee35e22e74f8">&#9670;&nbsp;</a></span>IsBorderVertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::IsBorderVertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if inner vertex v is an border vertex, that is, existing edge v-&gt;u or u-&gt;v, u is an outer vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if vertex v is border vertex, false otherwise. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>This method is only available when application set message strategy as kAlongEdgeToOuterVertex. </dd></dl>

</div>
</div>
<a id="a356f7be3210dd2f5c91d02b4fa01ec6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a356f7be3210dd2f5c91d02b4fa01ec6a">&#9670;&nbsp;</a></span>IsIncomingBorderVertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::IsIncomingBorderVertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if inner vertex v is an incoming border vertex, that is, existing edge u-&gt;v, u is an outer vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if vertex v is incoming border vertex, false otherwise. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>This method is only available when application set message strategy as kAlongOutgoingEdgeToOuterVertex. </dd></dl>

</div>
</div>
<a id="a234204d34e4bb4ab29db3e783cc6ca96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234204d34e4bb4ab29db3e783cc6ca96">&#9670;&nbsp;</a></span>IsInnerVertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::IsInnerVertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if vertex v is inner vertex of this fragment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if vertex v is an inner vertex, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1EdgecutFragmentBase.html#a3f5665c873f0ef620e82eff9ada8f7d3">grape::EdgecutFragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="ab7756802feddc434b5cc859895fa8a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7756802feddc434b5cc859895fa8a8e">&#9670;&nbsp;</a></span>IsOuterVertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::IsOuterVertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if vertex v is outer vertex of this fragment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if vertex v is outer vertex, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1EdgecutFragmentBase.html#ac881c1e98a81ce6fd566114c9ffa1e1e">grape::EdgecutFragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="aa7fac4408687a43bc911533f83a1a21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7fac4408687a43bc911533f83a1a21c">&#9670;&nbsp;</a></span>IsOutgoingBorderVertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::IsOutgoingBorderVertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if inner vertex v is an outgoing border vertex, that is, existing edge v-&gt;u, u is an outer vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if vertex v is outgoing border vertex, false otherwise. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>This method is only available when application set message strategy as kAlongIncomingEdgeToOuterVertex. </dd></dl>

</div>
</div>
<a id="a37c14b60e8f5ef696af45964d94095fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c14b60e8f5ef696af45964d94095fc">&#9670;&nbsp;</a></span>OEDests()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgrape_1_1DestList.html">DestList</a> <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::OEDests </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the outgoing edge destination fragment ID list of a <a class="el" href="classgrape_1_1Vertex.html" title="A Vertex object only contains id of a vertex. It will be used when iterating vertices of a fragment a...">Vertex</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The outgoing edge destination fragment ID list.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>This method is only available when application set message strategy as kAlongOutgoingedge_toOuterVertex. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1EdgecutFragmentBase.html#a60ba7cdd9ea4d6746749a7453b873287">grape::EdgecutFragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="a9ce3f1ebedef36bb59bc86b498eef757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce3f1ebedef36bb59bc86b498eef757">&#9670;&nbsp;</a></span>OuterVertexGid2Vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::OuterVertexGid2Vertex </td>
          <td>(</td>
          <td class="paramtype">const VID_T &amp;&#160;</td>
          <td class="paramname"><em>gid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert from global id to an outer vertex handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gid</td><td>Input global id. </td></tr>
    <tr><td class="paramname">v</td><td>Output vertex handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if exists an outer vertex of this fragment with global id as gid, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1EdgecutFragmentBase.html#a2e4cfdaa121ddb0d0d0dcb992a3edb35">grape::EdgecutFragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="adea82142c51e3091c841ee952f7bbb49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea82142c51e3091c841ee952f7bbb49">&#9670;&nbsp;</a></span>OuterVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgrape_1_1VertexRange.html">VertexRange</a>&lt;VID_T&gt; <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::OuterVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the vertex range of outer vertices in this fragment. </p>
<dl class="section return"><dt>Returns</dt><dd>The vertex range of outer vertices in this fragment. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1EdgecutFragmentBase.html#a55f0a1462edd59c9aafb4d058a738626">grape::EdgecutFragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="a7fabcf0f1863bac47ea3629ffd4f26d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fabcf0f1863bac47ea3629ffd4f26d8">&#9670;&nbsp;</a></span>PrepareToRunApp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::PrepareToRunApp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegrape.html#ad40e01301e786e48610a7570c132d93c">MessageStrategy</a>&#160;</td>
          <td class="paramname"><em>strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>need_split_edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For some kind of applications, specific data structures will be generated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strategy</td><td></td></tr>
    <tr><td class="paramname">need_split_edge</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classgrape_1_1FragmentBase.html#a0694d46ec5b5f6c9fe2130a834d284fb">grape::FragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="aaec612a7f6f84edc98f339951c727679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec612a7f6f84edc98f339951c727679">&#9670;&nbsp;</a></span>SetData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::SetData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VDATA_T &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the data of a vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vertex. </td></tr>
    <tr><td class="paramname">val</td><td>Data to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>This will only be applied locally, won't sync on other mirrors globally. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1FragmentBase.html#acc0ef513537168368a11cdcc52d9caa8">grape::FragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="a7dc05d739f4abae69e0e2b0482f14b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc05d739f4abae69e0e2b0482f14b08">&#9670;&nbsp;</a></span>Vertex2Gid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VID_T <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::Vertex2Gid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgrape_1_1Vertex.html">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert from vertex handle to its global id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vertex handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Global id of the vertex. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1FragmentBase.html#aac7c84de60bcf2f9b873a3cf3764c6c3">grape::FragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
<a id="a0ba9ed08a9f7d854598be5f2fa00f762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba9ed08a9f7d854598be5f2fa00f762">&#9670;&nbsp;</a></span>Vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OID_T , typename VID_T , typename VDATA_T , typename EDATA_T , LoadStrategy _load_strategy = LoadStrategy::kOnlyOut&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgrape_1_1VertexRange.html">VertexRange</a>&lt;VID_T&gt; <a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">grape::ImmutableEdgecutFragment</a>&lt; OID_T, VID_T, VDATA_T, EDATA_T, _load_strategy &gt;::Vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all vertices referenced to this fragment. </p>
<dl class="section return"><dt>Returns</dt><dd>A vertex set can be iterate on. </dd></dl>

<p>Implements <a class="el" href="classgrape_1_1FragmentBase.html#a0d9300c23a361566361e997fa3bcfedc">grape::FragmentBase&lt; OID_T, VID_T, VDATA_T, EDATA_T &gt;</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
