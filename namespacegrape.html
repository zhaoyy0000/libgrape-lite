<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libgrape-lite: grape Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libgrape-lite
   </div>
   <div id="projectbrief">A C++ library for parallel graph processing</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">grape Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A Worker manages the computation cycle. <a class="el" href="classgrape_1_1ParallelWorker.html">ParallelWorker</a> is a kind of worker for apps derived from <a class="el" href="classgrape_1_1ParallelAppBase.html" title="ParallelAppBase is a base class for parallel apps. Users can process messages in a more flexible way ...">ParallelAppBase</a>.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1AdjList.html">AdjList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A iteratable adjencent list of a vertex. The list contains all neighbors in format of <a class="el" href="structgrape_1_1Nbr.html" title="A neighbor of a vertex in the graph. ">Nbr</a>, which contains the other Node and the data on the <a class="el" href="classgrape_1_1Edge.html" title="Edge representation. ">Edge</a>.  <a href="classgrape_1_1AdjList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1Array.html">Array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgrape_1_1Array.html" title="Array a std::vector-like container type without reserving memory. ">Array</a> a std::vector-like container type without reserving memory.  <a href="classgrape_1_1Array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1Array_3_01EmptyType_00_01__Alloc_01_4.html">Array&lt; EmptyType, _Alloc &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization of <a class="el" href="classgrape_1_1Array.html" title="Array a std::vector-like container type without reserving memory. ">Array</a> for <a class="el" href="structgrape_1_1EmptyType.html" title="EmptyType is the placeholder of VDATA_T and EDATA_T for graphs without data on vertices and edges...">EmptyType</a>, without consuming extra memory for <a class="el" href="structgrape_1_1EmptyType.html" title="EmptyType is the placeholder of VDATA_T and EDATA_T for graphs without data on vertices and edges...">EmptyType</a> but provides same interfaces with <a class="el" href="classgrape_1_1Array.html" title="Array a std::vector-like container type without reserving memory. ">Array</a> of usual data types.  <a href="classgrape_1_1Array_3_01EmptyType_00_01__Alloc_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1AutoAppBase.html">AutoAppBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgrape_1_1AutoAppBase.html" title="AutoAppBase is a base class for auto-parallel apps. It contains an AutoParallelMessageManager to proc...">AutoAppBase</a> is a base class for auto-parallel apps. It contains an <a class="el" href="classgrape_1_1AutoParallelMessageManager.html" title="A kind of message manager supporting auto parallelism. ">AutoParallelMessageManager</a> to process messages implicitly during the computation.  <a href="classgrape_1_1AutoAppBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1AutoParallelMessageManager.html">AutoParallelMessageManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A kind of message manager supporting auto parallelism.  <a href="classgrape_1_1AutoParallelMessageManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1AutoWorker.html">AutoWorker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Worker manages the computation cycle. <a class="el" href="classgrape_1_1AutoWorker.html" title="A Worker manages the computation cycle. AutoWorker is a kind of worker for apps derived from AutoAppB...">AutoWorker</a> is a kind of worker for apps derived from <a class="el" href="classgrape_1_1AutoAppBase.html" title="AutoAppBase is a base class for auto-parallel apps. It contains an AutoParallelMessageManager to proc...">AutoAppBase</a>.  <a href="classgrape_1_1AutoWorker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1BasicFragmentLoader.html">BasicFragmentLoader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1BasicFragmentLoader_3_01FRAG__T_00_01PARTITIONER__T_00_01IOADAPTOR__T_00_01typenam8d49331e3f90045f1ce7948bb1a0221c.html">BasicFragmentLoader&lt; FRAG_T, PARTITIONER_T, IOADAPTOR_T, typename std::enable_if&lt; !std::is_same&lt; typename FRAG_T::vdata_t, EmptyType &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgrape_1_1BasicFragmentLoader.html">BasicFragmentLoader</a> manages temporal vertics/edges added by a more specific loader, shuffles data and builds fragments.  <a href="classgrape_1_1BasicFragmentLoader_3_01FRAG__T_00_01PARTITIONER__T_00_01IOADAPTOR__T_00_01typenam8d49331e3f90045f1ce7948bb1a0221c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1BasicFragmentLoader_3_01FRAG__T_00_01PARTITIONER__T_00_01IOADAPTOR__T_00_01typenamb0834b739ffae265bf7c6ac1e6974440.html">BasicFragmentLoader&lt; FRAG_T, PARTITIONER_T, IOADAPTOR_T, typename std::enable_if&lt; std::is_same&lt; typename FRAG_T::vdata_t, EmptyType &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgrape_1_1BasicFragmentLoader.html">BasicFragmentLoader</a> manages temporal vertics/edges added by a more specific loader, shuffles data and builds fragments.  <a href="classgrape_1_1BasicFragmentLoader_3_01FRAG__T_00_01PARTITIONER__T_00_01IOADAPTOR__T_00_01typenamb0834b739ffae265bf7c6ac1e6974440.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1BatchShuffleAppBase.html">BatchShuffleAppBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1BatchShuffleMessageManager.html">BatchShuffleMessageManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A kind of collective message manager.  <a href="classgrape_1_1BatchShuffleMessageManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1BatchShuffleWorker.html">BatchShuffleWorker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Worker manages the computation cycle. <a class="el" href="classgrape_1_1BatchShuffleAppBase.html">BatchShuffleAppBase</a> is a kind of worker for apps derived from <a class="el" href="classgrape_1_1BatchShuffleAppBase.html">BatchShuffleAppBase</a>.  <a href="classgrape_1_1BatchShuffleWorker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1Bitset.html">Bitset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgrape_1_1Bitset.html" title="Bitset is a highly-optimized bitset implementation. ">Bitset</a> is a highly-optimized bitset implementation.  <a href="classgrape_1_1Bitset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1BlockingQueue.html">BlockingQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concurrent queue based on condition_variables and can be accessed by multi-producers and multi-consumers simultaneously.  <a href="classgrape_1_1BlockingQueue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1CommSpec.html">CommSpec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgrape_1_1CommSpec.html" title="CommSpec records the mappings of fragments, workers, and the threads(tasks) in each worker...">CommSpec</a> records the mappings of fragments, workers, and the threads(tasks) in each worker.  <a href="classgrape_1_1CommSpec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1Communicator.html">Communicator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgrape_1_1Communicator.html" title="Communicator provides methods to implement distributed aggregation, such as Min/Max/Sum. ">Communicator</a> provides methods to implement distributed aggregation, such as Min/Max/Sum.  <a href="classgrape_1_1Communicator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ConstAdjList.html">ConstAdjList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A immutable iteratable adjencent list of a vertex. The list contains all neighbors in format of <a class="el" href="structgrape_1_1Nbr.html" title="A neighbor of a vertex in the graph. ">Nbr</a>, which contains the other Node and the data on the <a class="el" href="classgrape_1_1Edge.html" title="Edge representation. ">Edge</a>.  <a href="classgrape_1_1ConstAdjList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ContextBase.html">ContextBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgrape_1_1ContextBase.html" title="ContextBase is the base class for all user-defined contexts. A context manages data through the whole...">ContextBase</a> is the base class for all user-defined contexts. A context manages data through the whole computation. The data won't be cleared during supersteps.  <a href="classgrape_1_1ContextBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1DefaultAllocator.html">DefaultAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator used for grape containers, i.e., &lt;Array&gt;.  <a href="classgrape_1_1DefaultAllocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1DefaultMessageManager.html">DefaultMessageManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default message manager.  <a href="classgrape_1_1DefaultMessageManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1DenseVertexSet.html">DenseVertexSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vertex set with dense vertices.  <a href="classgrape_1_1DenseVertexSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgrape_1_1DestList.html">DestList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destination list for message exchange. A message may need to be sent to all the fragments in the <a class="el" href="structgrape_1_1DestList.html" title="Destination list for message exchange. A message may need to be sent to all the fragments in the Dest...">DestList</a>.  <a href="structgrape_1_1DestList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1Edge.html">Edge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgrape_1_1Edge.html" title="Edge representation. ">Edge</a> representation.  <a href="classgrape_1_1Edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1Edge_3_01VID__T_00_01EmptyType_01_4.html">Edge&lt; VID_T, EmptyType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialization for <a class="el" href="classgrape_1_1Edge.html" title="Edge representation. ">Edge</a> with <a class="el" href="structgrape_1_1EmptyType.html" title="EmptyType is the placeholder of VDATA_T and EDATA_T for graphs without data on vertices and edges...">EmptyType</a> on edge_data.  <a href="classgrape_1_1Edge_3_01VID__T_00_01EmptyType_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1EdgecutFragmentBase.html">EdgecutFragmentBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IEdgecutFragment defines the interfaces of fragments with edgecut. To learn more about edge-cut and vertex-cut, please refers to <a href="https://spark.apache.org/docs/1.6.2/graphx-programming-guide.html#optimized-representation">https://spark.apache.org/docs/1.6.2/graphx-programming-guide.html#optimized-representation</a>.  <a href="classgrape_1_1EdgecutFragmentBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgrape_1_1EmptyType.html">EmptyType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structgrape_1_1EmptyType.html" title="EmptyType is the placeholder of VDATA_T and EDATA_T for graphs without data on vertices and edges...">EmptyType</a> is the placeholder of VDATA_T and EDATA_T for graphs without data on vertices and edges.  <a href="structgrape_1_1EmptyType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1EVFragmentLoader.html">EVFragmentLoader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgrape_1_1EVFragmentLoader.html" title="EVFragmentLoader is a loader to load fragments from separated efile and vfile. ">EVFragmentLoader</a> is a loader to load fragments from separated efile and vfile.  <a href="classgrape_1_1EVFragmentLoader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgrape_1_1frag__shuffle__header.html">frag_shuffle_header</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1FragmentBase.html">FragmentBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgrape_1_1FragmentBase.html" title="FragmentBase is the base class for fragments. ">FragmentBase</a> is the base class for fragments.  <a href="classgrape_1_1FragmentBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1GlobalVertexMap.html">GlobalVertexMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a kind of <a class="el" href="classgrape_1_1VertexMapBase.html" title="VertexMapBase manages some mapping about vertices. ">VertexMapBase</a> which holds global mapping information in each worker.  <a href="classgrape_1_1GlobalVertexMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1HashPartitioner.html">HashPartitioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">HashPartitoner is a partitioner with the strategy of hashing on original vertex_ids.  <a href="classgrape_1_1HashPartitioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ImmutableEdgecutFragment.html">ImmutableEdgecutFragment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A kind of edgecut fragment.  <a href="classgrape_1_1ImmutableEdgecutFragment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1InArchive.html">InArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgrape_1_1InArchive.html" title="InArchive is an archived object for serializing objects. ">InArchive</a> is an archived object for serializing objects.  <a href="classgrape_1_1InArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1IOAdaptorBase.html">IOAdaptorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgrape_1_1IOAdaptorBase.html" title="IOAdaptorBase is the base class of I/O adaptors. ">IOAdaptorBase</a> is the base class of I/O adaptors.  <a href="classgrape_1_1IOAdaptorBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ISyncBuffer.html">ISyncBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgrape_1_1ISyncBuffer.html" title="ISyncBuffer is a base class of SyncBuffer, which is used for auto parallelization. ">ISyncBuffer</a> is a base class of <a class="el" href="classgrape_1_1SyncBuffer.html" title="SyncBuffer manages status on each vertex during the evaluation in auto parallization. ">SyncBuffer</a>, which is used for auto parallelization.  <a href="classgrape_1_1ISyncBuffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1IteratorPair.html">IteratorPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgrape_1_1IteratorPair.html" title="IteratorPair is a wrapper for begin and end iterators. ">IteratorPair</a> is a wrapper for begin and end iterators.  <a href="classgrape_1_1IteratorPair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1LineParserBase.html">LineParserBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgrape_1_1LineParserBase.html" title="LineParserBase is the base class for line parsers. ">LineParserBase</a> is the base class for line parsers.  <a href="classgrape_1_1LineParserBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgrape_1_1LoadGraphSpec.html">LoadGraphSpec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structgrape_1_1LoadGraphSpec.html" title="LoadGraphSpec determines the specification to load a graph. ">LoadGraphSpec</a> determines the specification to load a graph.  <a href="structgrape_1_1LoadGraphSpec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1LocalIOAdaptor.html">LocalIOAdaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default adaptor to read/write files from local locations.  <a href="classgrape_1_1LocalIOAdaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1MessageManagerBase.html">MessageManagerBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgrape_1_1MessageManagerBase.html" title="MessageManagerBase is the base class for message managers. ">MessageManagerBase</a> is the base class for message managers.  <a href="classgrape_1_1MessageManagerBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgrape_1_1Nbr.html">Nbr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A neighbor of a vertex in the graph.  <a href="structgrape_1_1Nbr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgrape_1_1Nbr_3_01VID__T_00_01EmptyType_01_4.html">Nbr&lt; VID_T, EmptyType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A neighbor of a vertex in the graph. (partial specialization with Empty edge data.)  <a href="structgrape_1_1Nbr_3_01VID__T_00_01EmptyType_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1NonblockingQueue.html">NonblockingQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concurrent queue guarded by a spinlock and can be accessed by multi-producers and multi-consumers simultaneously.  <a href="classgrape_1_1NonblockingQueue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgrape_1_1OutArchive.html" title="OutArchive is an archived object for deserializing objects. ">OutArchive</a> is an archived object for deserializing objects.  <a href="classgrape_1_1OutArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ParallelAppBase.html">ParallelAppBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgrape_1_1ParallelAppBase.html" title="ParallelAppBase is a base class for parallel apps. Users can process messages in a more flexible way ...">ParallelAppBase</a> is a base class for parallel apps. Users can process messages in a more flexible way in this kind of app. It contains an <a class="el" href="classgrape_1_1ParallelMessageManager.html" title="A kind of parallel message manager. ">ParallelMessageManager</a> to process messages, which enables send/receive messages during computation. This strategy improves performance by overlapping the communication time and the evaluation time.  <a href="classgrape_1_1ParallelAppBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ParallelEngine.html">ParallelEngine</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgrape_1_1ParallelEngineSpec.html">ParallelEngineSpec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ParallelMessageManager.html">ParallelMessageManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A kind of parallel message manager.  <a href="classgrape_1_1ParallelMessageManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ParallelWorker.html">ParallelWorker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1Rebalancer.html">Rebalancer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgrape_1_1Rebalancer.html" title="Rebalancer aims to rebalance the edges between fragments. For some skewed graphs, hash partitioning o...">Rebalancer</a> aims to rebalance the edges between fragments. For some skewed graphs, hash partitioning on vertex_ids may leads to imbalanced workload in workers. <a class="el" href="classgrape_1_1Rebalancer.html" title="Rebalancer aims to rebalance the edges between fragments. For some skewed graphs, hash partitioning o...">Rebalancer</a> tries to reallocate some vertices and edges in these cases.  <a href="classgrape_1_1Rebalancer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1Rebalancer_3_01FRAG__T_00_01typename_01std_1_1enable__if_3_01std_1_1is__same_3_01t7fe5a7a3ae769a6c3acd72145af3f19c.html">Rebalancer&lt; FRAG_T, typename std::enable_if&lt; std::is_same&lt; typename FRAG_T::vdata_t, EmptyType &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1Rebalancer_3_01FRAG__T_00_01typename_01std_1_1enable__if_3_9std_1_1is__same_3_01tyb20620ca2c067267082ea965704264d2.html">Rebalancer&lt; FRAG_T, typename std::enable_if&lt;!std::is_same&lt; typename FRAG_T::vdata_t, EmptyType &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1RefBitset.html">RefBitset</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1SegmentedPartitioner.html">SegmentedPartitioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgrape_1_1SegmentedPartitioner.html" title="SegmentedPartitioner is a partitioner with a strategy of chunking original vertex_ids. ">SegmentedPartitioner</a> is a partitioner with a strategy of chunking original vertex_ids.  <a href="classgrape_1_1SegmentedPartitioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ShuffleInPair.html">ShuffleInPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ShuffleIn for two &lt;ShuffleUnit&gt;s.  <a href="classgrape_1_1ShuffleInPair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ShuffleInTriple.html">ShuffleInTriple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ShuffleIn for three &lt;ShuffleUnit&gt;s.  <a href="classgrape_1_1ShuffleInTriple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ShuffleInUnary.html">ShuffleInUnary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ShuffleIn for a &lt;ShuffleUnit&gt;.  <a href="classgrape_1_1ShuffleInUnary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ShuffleOutPair.html">ShuffleOutPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ShuffleOut for two &lt;ShuffleUnit&gt;s.  <a href="classgrape_1_1ShuffleOutPair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ShuffleOutTriple.html">ShuffleOutTriple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ShuffleOut for three &lt;ShuffleUnit&gt;s.  <a href="classgrape_1_1ShuffleOutTriple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ShuffleOutUnary.html">ShuffleOutUnary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ShuffleOut for a &lt;ShuffleUnit&gt;.  <a href="classgrape_1_1ShuffleOutUnary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ShuffleUnit.html">ShuffleUnit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgrape_1_1ShuffleUnit.html" title="ShuffleUnit wraps a vector, for data shuffling between workers. ">ShuffleUnit</a> wraps a vector, for data shuffling between workers.  <a href="classgrape_1_1ShuffleUnit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1SpinLock.html">SpinLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple implementation of spinlock based on std::atomic.  <a href="classgrape_1_1SpinLock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1SyncBuffer.html">SyncBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgrape_1_1SyncBuffer.html" title="SyncBuffer manages status on each vertex during the evaluation in auto parallization. ">SyncBuffer</a> manages status on each vertex during the evaluation in auto parallization.  <a href="classgrape_1_1SyncBuffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1ThreadLocalMessageBuffer.html">ThreadLocalMessageBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1TSVLineParser.html">TSVLineParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a default parser for tsv files.  <a href="classgrape_1_1TSVLineParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1Vertex.html">Vertex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classgrape_1_1Vertex.html" title="A Vertex object only contains id of a vertex. It will be used when iterating vertices of a fragment a...">Vertex</a> object only contains id of a vertex. It will be used when iterating vertices of a fragment and accessing data and neighbor of a vertex.  <a href="classgrape_1_1Vertex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1VertexArray.html">VertexArray</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1VertexMapBase.html">VertexMapBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgrape_1_1VertexMapBase.html" title="VertexMapBase manages some mapping about vertices. ">VertexMapBase</a> manages some mapping about vertices.  <a href="classgrape_1_1VertexMapBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrape_1_1VertexRange.html">VertexRange</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af44defe8f89dea181fac4cadbac37561"><td class="memItemLeft" align="right" valign="top"><a id="af44defe8f89dea181fac4cadbac37561"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>fid_t</b> = unsigned</td></tr>
<tr class="separator:af44defe8f89dea181fac4cadbac37561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4242699c9b8622a180126664e2a8bc"><td class="memTemplParams" colspan="2"><a id="a7f4242699c9b8622a180126664e2a8bc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7f4242699c9b8622a180126664e2a8bc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Allocator</b> = <a class="el" href="classgrape_1_1DefaultAllocator.html">DefaultAllocator</a>&lt; T &gt;</td></tr>
<tr class="separator:a7f4242699c9b8622a180126664e2a8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2458f7926f1fa0b675fa3ff2b9add05b"><td class="memTemplParams" colspan="2"><a id="a2458f7926f1fa0b675fa3ff2b9add05b"></a>
template&lt;typename E &gt; </td></tr>
<tr class="memitem:a2458f7926f1fa0b675fa3ff2b9add05b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enable_enum_t</b> = typename std::enable_if&lt; std::is_enum&lt; E &gt;::value, typename std::underlying_type&lt; E &gt;::type &gt;::type</td></tr>
<tr class="separator:a2458f7926f1fa0b675fa3ff2b9add05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac82896434bbf475bc211722dc2257fbf"><td class="memItemLeft" align="right" valign="top"><a id="ac82896434bbf475bc211722dc2257fbf"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegrape.html#ac82896434bbf475bc211722dc2257fbf">LoadStrategy</a> { <b>kOnlyOut</b> = 0, 
<b>kOnlyIn</b> = 1, 
<b>kBothOutIn</b> = 2, 
<b>kNullLoadStrategy</b> = 0xf0
 }<tr class="memdesc:ac82896434bbf475bc211722dc2257fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">LoadStrategy specifies the which edges should be loadded when building the graph from a location. <br /></td></tr>
</td></tr>
<tr class="separator:ac82896434bbf475bc211722dc2257fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40e01301e786e48610a7570c132d93c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegrape.html#ad40e01301e786e48610a7570c132d93c">MessageStrategy</a> { <b>kAlongOutgoingEdgeToOuterVertex</b> = 0, 
<a class="el" href="namespacegrape.html#ad40e01301e786e48610a7570c132d93ca27407bfcdec900987bb5a513e6634604">MessageStrategy::kAlongIncomingEdgeToOuterVertex</a> = 1, 
<a class="el" href="namespacegrape.html#ad40e01301e786e48610a7570c132d93caa79427df483e13f39252db6cf07e6d6b">MessageStrategy::kAlongEdgeToOuterVertex</a> = 2, 
<a class="el" href="namespacegrape.html#ad40e01301e786e48610a7570c132d93cad6fbc9535d3da66fc48363c13f8c50d2">MessageStrategy::kSyncOnOuterVertex</a> = 3
 }<tr class="memdesc:ad40e01301e786e48610a7570c132d93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">MessageStrategy specifies the method of message passing between fragments.  <a href="namespacegrape.html#ad40e01301e786e48610a7570c132d93c">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ad40e01301e786e48610a7570c132d93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aefeb0b2717e66c64576d1e9a51046d00"><td class="memTemplParams" colspan="2"><a id="aefeb0b2717e66c64576d1e9a51046d00"></a>
template&lt;typename APP_T &gt; </td></tr>
<tr class="memitem:aefeb0b2717e66c64576d1e9a51046d00"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="classgrape_1_1Communicator.html">Communicator</a>, APP_T &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InitCommunicator</b> (std::shared_ptr&lt; APP_T &gt; app, MPI_Comm comm)</td></tr>
<tr class="separator:aefeb0b2717e66c64576d1e9a51046d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac655db3d3d062e0e9363bbff8a5c9901"><td class="memTemplParams" colspan="2"><a id="ac655db3d3d062e0e9363bbff8a5c9901"></a>
template&lt;typename APP_T &gt; </td></tr>
<tr class="memitem:ac655db3d3d062e0e9363bbff8a5c9901"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_base_of&lt; <a class="el" href="classgrape_1_1Communicator.html">Communicator</a>, APP_T &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InitCommunicator</b> (std::shared_ptr&lt; APP_T &gt; app, MPI_Comm comm)</td></tr>
<tr class="separator:ac655db3d3d062e0e9363bbff8a5c9901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8acba842f02c5a2ecc806e90aa4ebf3"><td class="memItemLeft" align="right" valign="top"><a id="ae8acba842f02c5a2ecc806e90aa4ebf3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>InitMPIComm</b> ()</td></tr>
<tr class="separator:ae8acba842f02c5a2ecc806e90aa4ebf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38385545b413250b3d9d0d0562903f58"><td class="memItemLeft" align="right" valign="top"><a id="a38385545b413250b3d9d0d0562903f58"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>FinalizeMPIComm</b> ()</td></tr>
<tr class="separator:a38385545b413250b3d9d0d0562903f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19de7a94300075bb61faffb286aaaab2"><td class="memTemplParams" colspan="2"><a id="a19de7a94300075bb61faffb286aaaab2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a19de7a94300075bb61faffb286aaaab2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SendVector</b> (const std::vector&lt; T &gt; &amp;vec, int dst_worker_id, MPI_Comm comm, int tag=0)</td></tr>
<tr class="separator:a19de7a94300075bb61faffb286aaaab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fadf206527fc9f45d5746c7b2a408fa"><td class="memTemplParams" colspan="2"><a id="a8fadf206527fc9f45d5746c7b2a408fa"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8fadf206527fc9f45d5746c7b2a408fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>RecvVector</b> (std::vector&lt; T &gt; &amp;vec, int src_worker_id, MPI_Comm comm, int tag=0)</td></tr>
<tr class="separator:a8fadf206527fc9f45d5746c7b2a408fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393108a97e9aa65c95f70e64eb7832c7"><td class="memItemLeft" align="right" valign="top"><a id="a393108a97e9aa65c95f70e64eb7832c7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SendArchive</b> (const <a class="el" href="classgrape_1_1InArchive.html">InArchive</a> &amp;archive, int dst_worker_id, MPI_Comm comm, int tag=0)</td></tr>
<tr class="separator:a393108a97e9aa65c95f70e64eb7832c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3eb7686bdcc12fba7670a5958bf4792"><td class="memItemLeft" align="right" valign="top"><a id="ae3eb7686bdcc12fba7670a5958bf4792"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RecvArchive</b> (<a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a> &amp;archive, int src_worker_id, MPI_Comm comm, int tag=0)</td></tr>
<tr class="separator:ae3eb7686bdcc12fba7670a5958bf4792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab156985420e492012edcac7fb035053"><td class="memTemplParams" colspan="2"><a id="aab156985420e492012edcac7fb035053"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aab156985420e492012edcac7fb035053"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>BcastSend</b> (const T &amp;object, MPI_Comm comm)</td></tr>
<tr class="separator:aab156985420e492012edcac7fb035053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec83bda19ac434a7f32f18c3c9da14d"><td class="memTemplParams" colspan="2"><a id="aaec83bda19ac434a7f32f18c3c9da14d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aaec83bda19ac434a7f32f18c3c9da14d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>BcastRecv</b> (T &amp;object, MPI_Comm comm, int root)</td></tr>
<tr class="separator:aaec83bda19ac434a7f32f18c3c9da14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d53f0cd0426aa40064fa2e1dd5dcbb"><td class="memTemplParams" colspan="2"><a id="a24d53f0cd0426aa40064fa2e1dd5dcbb"></a>
template&lt;typename OID_T , typename VDATA_T &gt; </td></tr>
<tr class="memitem:a24d53f0cd0426aa40064fa2e1dd5dcbb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compare_by_id</b> (const <a class="el" href="classgrape_1_1internal_1_1Vertex.html">internal::Vertex</a>&lt; OID_T, VDATA_T &gt; &amp;lhs, const <a class="el" href="classgrape_1_1internal_1_1Vertex.html">internal::Vertex</a>&lt; OID_T, VDATA_T &gt; &amp;rhs)</td></tr>
<tr class="separator:a24d53f0cd0426aa40064fa2e1dd5dcbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc84dbce937c6d3a61e3113a489f38f"><td class="memItemLeft" align="right" valign="top"><a id="a1cc84dbce937c6d3a61e3113a489f38f"></a>
<a class="el" href="structgrape_1_1LoadGraphSpec.html">LoadGraphSpec</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DefaultLoadGraphSpec</b> ()</td></tr>
<tr class="separator:a1cc84dbce937c6d3a61e3113a489f38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6433aadaafce74ace19c679efec0968f"><td class="memTemplParams" colspan="2"><a id="a6433aadaafce74ace19c679efec0968f"></a>
template&lt;typename VID_T , typename EDATA_T &gt; </td></tr>
<tr class="memitem:a6433aadaafce74ace19c679efec0968f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1InArchive.html">InArchive</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classgrape_1_1InArchive.html">InArchive</a> &amp;archive, const <a class="el" href="structgrape_1_1Nbr.html">Nbr</a>&lt; VID_T, EDATA_T &gt; &amp;nbr)</td></tr>
<tr class="separator:a6433aadaafce74ace19c679efec0968f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5ab767194f7a7c3bfe185d97d4ae68"><td class="memTemplParams" colspan="2"><a id="aeb5ab767194f7a7c3bfe185d97d4ae68"></a>
template&lt;typename VID_T &gt; </td></tr>
<tr class="memitem:aeb5ab767194f7a7c3bfe185d97d4ae68"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1InArchive.html">InArchive</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classgrape_1_1InArchive.html">InArchive</a> &amp;archive, const <a class="el" href="structgrape_1_1Nbr.html">Nbr</a>&lt; VID_T, <a class="el" href="structgrape_1_1EmptyType.html">EmptyType</a> &gt; &amp;nbr)</td></tr>
<tr class="separator:aeb5ab767194f7a7c3bfe185d97d4ae68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9263ec7e66ce06d055f154ef2d5c06"><td class="memTemplParams" colspan="2"><a id="a1a9263ec7e66ce06d055f154ef2d5c06"></a>
template&lt;typename VID_T , typename EDATA_T &gt; </td></tr>
<tr class="memitem:a1a9263ec7e66ce06d055f154ef2d5c06"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (<a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a> &amp;archive, <a class="el" href="structgrape_1_1Nbr.html">Nbr</a>&lt; VID_T, EDATA_T &gt; &amp;nbr)</td></tr>
<tr class="separator:a1a9263ec7e66ce06d055f154ef2d5c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361ba03cd5e7aa0c57edbca2408a5447"><td class="memTemplParams" colspan="2"><a id="a361ba03cd5e7aa0c57edbca2408a5447"></a>
template&lt;typename VID_T &gt; </td></tr>
<tr class="memitem:a361ba03cd5e7aa0c57edbca2408a5447"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (<a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a> &amp;archive, <a class="el" href="structgrape_1_1Nbr.html">Nbr</a>&lt; VID_T, <a class="el" href="structgrape_1_1EmptyType.html">EmptyType</a> &gt; &amp;nbr)</td></tr>
<tr class="separator:a361ba03cd5e7aa0c57edbca2408a5447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d809a5e28de4b45697ec1f6bcc0842a"><td class="memItemLeft" align="right" valign="top"><a id="a5d809a5e28de4b45697ec1f6bcc0842a"></a>
<a class="el" href="structgrape_1_1ParallelEngineSpec.html">ParallelEngineSpec</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DefaultParallelEngineSpec</b> ()</td></tr>
<tr class="separator:a5d809a5e28de4b45697ec1f6bcc0842a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ab7d897274f2bf927727da18d032e9"><td class="memItemLeft" align="right" valign="top"><a id="a16ab7d897274f2bf927727da18d032e9"></a>
<a class="el" href="structgrape_1_1ParallelEngineSpec.html">ParallelEngineSpec</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MultiProcessSpec</b> (const <a class="el" href="classgrape_1_1CommSpec.html">CommSpec</a> &amp;comm_spec, bool affinity=false)</td></tr>
<tr class="separator:a16ab7d897274f2bf927727da18d032e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4355f64e9a421442f9bdf9bfabe41e4d"><td class="memTemplParams" colspan="2"><a id="a4355f64e9a421442f9bdf9bfabe41e4d"></a>
template&lt;typename APP_T &gt; </td></tr>
<tr class="memitem:a4355f64e9a421442f9bdf9bfabe41e4d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="classgrape_1_1ParallelEngine.html">ParallelEngine</a>, APP_T &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InitParallelEngine</b> (std::shared_ptr&lt; APP_T &gt; app, const <a class="el" href="structgrape_1_1ParallelEngineSpec.html">ParallelEngineSpec</a> &amp;spec)</td></tr>
<tr class="separator:a4355f64e9a421442f9bdf9bfabe41e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319dbba7d50fc3cccf8b754facfee188"><td class="memTemplParams" colspan="2"><a id="a319dbba7d50fc3cccf8b754facfee188"></a>
template&lt;typename APP_T &gt; </td></tr>
<tr class="memitem:a319dbba7d50fc3cccf8b754facfee188"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_base_of&lt; <a class="el" href="classgrape_1_1ParallelEngine.html">ParallelEngine</a>, APP_T &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InitParallelEngine</b> (std::shared_ptr&lt; APP_T &gt; app, const <a class="el" href="structgrape_1_1ParallelEngineSpec.html">ParallelEngineSpec</a> &amp;spec)</td></tr>
<tr class="separator:a319dbba7d50fc3cccf8b754facfee188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40881c832fdd2c4560d188578ad0d07a"><td class="memTemplParams" colspan="2"><a id="a40881c832fdd2c4560d188578ad0d07a"></a>
template&lt;typename T , typename std::enable_if&lt; std::is_pod&lt; T &gt;::value, T &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a40881c832fdd2c4560d188578ad0d07a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1InArchive.html">InArchive</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classgrape_1_1InArchive.html">InArchive</a> &amp;in_archive, T u)</td></tr>
<tr class="separator:a40881c832fdd2c4560d188578ad0d07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafea2b5f0163459762e8a86147026335"><td class="memItemLeft" align="right" valign="top"><a id="aafea2b5f0163459762e8a86147026335"></a>
<a class="el" href="classgrape_1_1InArchive.html">InArchive</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classgrape_1_1InArchive.html">InArchive</a> &amp;in_archive, <a class="el" href="structgrape_1_1EmptyType.html">EmptyType</a>)</td></tr>
<tr class="separator:aafea2b5f0163459762e8a86147026335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeffb36ec1b5c235226ffbda946181c30"><td class="memItemLeft" align="right" valign="top"><a id="aeffb36ec1b5c235226ffbda946181c30"></a>
<a class="el" href="classgrape_1_1InArchive.html">InArchive</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classgrape_1_1InArchive.html">InArchive</a> &amp;in_archive, const std::string &amp;str)</td></tr>
<tr class="separator:aeffb36ec1b5c235226ffbda946181c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660102f406166bc43c276fae3cf73d4c"><td class="memTemplParams" colspan="2"><a id="a660102f406166bc43c276fae3cf73d4c"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a660102f406166bc43c276fae3cf73d4c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1InArchive.html">InArchive</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classgrape_1_1InArchive.html">InArchive</a> &amp;in_archive, const std::pair&lt; T1, T2 &gt; &amp;p)</td></tr>
<tr class="separator:a660102f406166bc43c276fae3cf73d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36076927c9a40a432537cf1a5a5ee18f"><td class="memTemplParams" colspan="2"><a id="a36076927c9a40a432537cf1a5a5ee18f"></a>
template&lt;typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:a36076927c9a40a432537cf1a5a5ee18f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1InArchive.html">InArchive</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classgrape_1_1InArchive.html">InArchive</a> &amp;in_archive, const std::tuple&lt; T1, T2, T3 &gt; &amp;t)</td></tr>
<tr class="separator:a36076927c9a40a432537cf1a5a5ee18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5603b785417153254c44da933b8aad"><td class="memTemplParams" colspan="2"><a id="a5b5603b785417153254c44da933b8aad"></a>
template&lt;typename T , typename std::enable_if&lt; std::is_pod&lt; T &gt;::value, T &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a5b5603b785417153254c44da933b8aad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1InArchive.html">InArchive</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classgrape_1_1InArchive.html">InArchive</a> &amp;in_archive, const std::vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="separator:a5b5603b785417153254c44da933b8aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781e8983b2b0349dbaced1e365a75fab"><td class="memTemplParams" colspan="2"><a id="a781e8983b2b0349dbaced1e365a75fab"></a>
template&lt;typename T , typename ALLOC_T , typename std::enable_if&lt;!std::is_pod&lt; T &gt;::value, T &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a781e8983b2b0349dbaced1e365a75fab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1InArchive.html">InArchive</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classgrape_1_1InArchive.html">InArchive</a> &amp;in_archive, const std::vector&lt; T, ALLOC_T &gt; &amp;vec)</td></tr>
<tr class="separator:a781e8983b2b0349dbaced1e365a75fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add72bd730d10a15ac837145648e9bdcb"><td class="memTemplParams" colspan="2"><a id="add72bd730d10a15ac837145648e9bdcb"></a>
template&lt;typename ALLOC_T &gt; </td></tr>
<tr class="memitem:add72bd730d10a15ac837145648e9bdcb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1InArchive.html">InArchive</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classgrape_1_1InArchive.html">InArchive</a> &amp;in_archive, const std::vector&lt; <a class="el" href="structgrape_1_1EmptyType.html">EmptyType</a>, ALLOC_T &gt; &amp;vec)</td></tr>
<tr class="separator:add72bd730d10a15ac837145648e9bdcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23cda543f92b6c44cfa8ee2010fcf3b5"><td class="memTemplParams" colspan="2"><a id="a23cda543f92b6c44cfa8ee2010fcf3b5"></a>
template&lt;typename T , typename ALLOC_T , typename std::enable_if&lt; std::is_pod&lt; T &gt;::value, T &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a23cda543f92b6c44cfa8ee2010fcf3b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1InArchive.html">InArchive</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classgrape_1_1InArchive.html">InArchive</a> &amp;in_archive, const <a class="el" href="classgrape_1_1Array.html">Array</a>&lt; T, ALLOC_T &gt; &amp;vec)</td></tr>
<tr class="separator:a23cda543f92b6c44cfa8ee2010fcf3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfc4801b7b15eb1d2e739d139d7c9ea"><td class="memTemplParams" colspan="2"><a id="a9bfc4801b7b15eb1d2e739d139d7c9ea"></a>
template&lt;typename ALLOC_T &gt; </td></tr>
<tr class="memitem:a9bfc4801b7b15eb1d2e739d139d7c9ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1InArchive.html">InArchive</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classgrape_1_1InArchive.html">InArchive</a> &amp;in_archive, const <a class="el" href="classgrape_1_1Array.html">Array</a>&lt; <a class="el" href="structgrape_1_1EmptyType.html">EmptyType</a>, ALLOC_T &gt; &amp;vec)</td></tr>
<tr class="separator:a9bfc4801b7b15eb1d2e739d139d7c9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142694ad67992afbc6dd0f541ceb1cac"><td class="memTemplParams" colspan="2"><a id="a142694ad67992afbc6dd0f541ceb1cac"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a142694ad67992afbc6dd0f541ceb1cac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1InArchive.html">InArchive</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classgrape_1_1InArchive.html">InArchive</a> &amp;in_archive, const std::set&lt; T &gt; &amp;s)</td></tr>
<tr class="separator:a142694ad67992afbc6dd0f541ceb1cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627749a3d95e351a679e3c26b77759ff"><td class="memTemplParams" colspan="2"><a id="a627749a3d95e351a679e3c26b77759ff"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a627749a3d95e351a679e3c26b77759ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1InArchive.html">InArchive</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classgrape_1_1InArchive.html">InArchive</a> &amp;in_archive, const std::unordered_set&lt; T &gt; &amp;s)</td></tr>
<tr class="separator:a627749a3d95e351a679e3c26b77759ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25875e86be22b40d9ab1dfba2eceb48"><td class="memTemplParams" colspan="2"><a id="ab25875e86be22b40d9ab1dfba2eceb48"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ab25875e86be22b40d9ab1dfba2eceb48"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1InArchive.html">InArchive</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classgrape_1_1InArchive.html">InArchive</a> &amp;in_archive, const std::map&lt; T1, T2 &gt; &amp;m)</td></tr>
<tr class="separator:ab25875e86be22b40d9ab1dfba2eceb48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339261ccfdd36915b288cd9aee98772f"><td class="memTemplParams" colspan="2"><a id="a339261ccfdd36915b288cd9aee98772f"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a339261ccfdd36915b288cd9aee98772f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1InArchive.html">InArchive</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classgrape_1_1InArchive.html">InArchive</a> &amp;in_archive, const std::unordered_map&lt; T1, T2 &gt; &amp;m)</td></tr>
<tr class="separator:a339261ccfdd36915b288cd9aee98772f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4efe0dd207bcaff0a484870bacd82348"><td class="memTemplParams" colspan="2"><a id="a4efe0dd207bcaff0a484870bacd82348"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a4efe0dd207bcaff0a484870bacd82348"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1InArchive.html">InArchive</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classgrape_1_1InArchive.html">InArchive</a> &amp;in_archive, const ska::flat_hash_map&lt; T1, T2 &gt; &amp;m)</td></tr>
<tr class="separator:a4efe0dd207bcaff0a484870bacd82348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752aae63c2cfe81413afa84964530f01"><td class="memTemplParams" colspan="2"><a id="a752aae63c2cfe81413afa84964530f01"></a>
template&lt;typename T , typename std::enable_if&lt; std::is_pod&lt; T &gt;::value, T &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a752aae63c2cfe81413afa84964530f01"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (<a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a> &amp;out_archive, T &amp;u)</td></tr>
<tr class="separator:a752aae63c2cfe81413afa84964530f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4dbf1fcd7332e79d0bfc8dcd9a94e8"><td class="memItemLeft" align="right" valign="top"><a id="abd4dbf1fcd7332e79d0bfc8dcd9a94e8"></a>
<a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (<a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a> &amp;out_archive, <a class="el" href="structgrape_1_1EmptyType.html">EmptyType</a> &amp;)</td></tr>
<tr class="separator:abd4dbf1fcd7332e79d0bfc8dcd9a94e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e96eb1d3d58e901324613d9c1cf5548"><td class="memItemLeft" align="right" valign="top"><a id="a4e96eb1d3d58e901324613d9c1cf5548"></a>
<a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (<a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a> &amp;out_archive, std::string &amp;str)</td></tr>
<tr class="separator:a4e96eb1d3d58e901324613d9c1cf5548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65de3ac64ad57829466337f3f788be63"><td class="memTemplParams" colspan="2"><a id="a65de3ac64ad57829466337f3f788be63"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a65de3ac64ad57829466337f3f788be63"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (<a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a> &amp;out_archive, std::pair&lt; T1, T2 &gt; &amp;p)</td></tr>
<tr class="separator:a65de3ac64ad57829466337f3f788be63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ea11b96436fc151c00aafd64e77171"><td class="memTemplParams" colspan="2"><a id="a77ea11b96436fc151c00aafd64e77171"></a>
template&lt;typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:a77ea11b96436fc151c00aafd64e77171"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (<a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a> &amp;out_archive, std::tuple&lt; T1, T2, T3 &gt; &amp;t)</td></tr>
<tr class="separator:a77ea11b96436fc151c00aafd64e77171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add701cbd3ee20fe1440dcd7da30c6a1e"><td class="memTemplParams" colspan="2"><a id="add701cbd3ee20fe1440dcd7da30c6a1e"></a>
template&lt;typename T , typename std::enable_if&lt; std::is_pod&lt; T &gt;::value, T &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:add701cbd3ee20fe1440dcd7da30c6a1e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (<a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a> &amp;out_archive, std::vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="separator:add701cbd3ee20fe1440dcd7da30c6a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b364171d5651c79edda71074e5d89d"><td class="memTemplParams" colspan="2"><a id="aa3b364171d5651c79edda71074e5d89d"></a>
template&lt;typename T , typename ALLOC_T , typename std::enable_if&lt;!std::is_pod&lt; T &gt;::value, T &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aa3b364171d5651c79edda71074e5d89d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (<a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a> &amp;out_archive, std::vector&lt; T, ALLOC_T &gt; &amp;vec)</td></tr>
<tr class="separator:aa3b364171d5651c79edda71074e5d89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28368466fcff81a0b0fd4fe5807b9dc5"><td class="memTemplParams" colspan="2"><a id="a28368466fcff81a0b0fd4fe5807b9dc5"></a>
template&lt;typename ALLOC_T &gt; </td></tr>
<tr class="memitem:a28368466fcff81a0b0fd4fe5807b9dc5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (<a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a> &amp;out_archive, std::vector&lt; <a class="el" href="structgrape_1_1EmptyType.html">EmptyType</a>, ALLOC_T &gt; &amp;vec)</td></tr>
<tr class="separator:a28368466fcff81a0b0fd4fe5807b9dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2527ef646bf5a1ae2a4c1a4e0a9f745a"><td class="memTemplParams" colspan="2"><a id="a2527ef646bf5a1ae2a4c1a4e0a9f745a"></a>
template&lt;typename T , typename ALLOC_T , typename std::enable_if&lt; std::is_pod&lt; T &gt;::value, T &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a2527ef646bf5a1ae2a4c1a4e0a9f745a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (<a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a> &amp;out_archive, <a class="el" href="classgrape_1_1Array.html">Array</a>&lt; T, ALLOC_T &gt; &amp;vec)</td></tr>
<tr class="separator:a2527ef646bf5a1ae2a4c1a4e0a9f745a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5cc85ad3d4fb8986efb5ae24fe8a9eb"><td class="memTemplParams" colspan="2"><a id="aa5cc85ad3d4fb8986efb5ae24fe8a9eb"></a>
template&lt;typename ALLOC_T &gt; </td></tr>
<tr class="memitem:aa5cc85ad3d4fb8986efb5ae24fe8a9eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (<a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a> &amp;out_archive, <a class="el" href="classgrape_1_1Array.html">Array</a>&lt; <a class="el" href="structgrape_1_1EmptyType.html">EmptyType</a>, ALLOC_T &gt; &amp;vec)</td></tr>
<tr class="separator:aa5cc85ad3d4fb8986efb5ae24fe8a9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa470933a2efa288327a23fe0c4d3c2"><td class="memTemplParams" colspan="2"><a id="a9fa470933a2efa288327a23fe0c4d3c2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9fa470933a2efa288327a23fe0c4d3c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (<a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a> &amp;out_archive, std::set&lt; T &gt; &amp;s)</td></tr>
<tr class="separator:a9fa470933a2efa288327a23fe0c4d3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8082643d28aa45adc0f85c933df273"><td class="memTemplParams" colspan="2"><a id="a8e8082643d28aa45adc0f85c933df273"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8e8082643d28aa45adc0f85c933df273"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (<a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a> &amp;out_archive, std::unordered_set&lt; T &gt; &amp;s)</td></tr>
<tr class="separator:a8e8082643d28aa45adc0f85c933df273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cad9698207dbeb58edd8e2d6f4bde08"><td class="memTemplParams" colspan="2"><a id="a0cad9698207dbeb58edd8e2d6f4bde08"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a0cad9698207dbeb58edd8e2d6f4bde08"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (<a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a> &amp;out_archive, std::map&lt; T1, T2 &gt; &amp;m)</td></tr>
<tr class="separator:a0cad9698207dbeb58edd8e2d6f4bde08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f006e10ed7cc416e4b58ea8dd3b433"><td class="memTemplParams" colspan="2"><a id="a93f006e10ed7cc416e4b58ea8dd3b433"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a93f006e10ed7cc416e4b58ea8dd3b433"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (<a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a> &amp;out_archive, std::unordered_map&lt; T1, T2 &gt; &amp;m)</td></tr>
<tr class="separator:a93f006e10ed7cc416e4b58ea8dd3b433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e322c6f031abfca32940fd343cda46"><td class="memTemplParams" colspan="2"><a id="a22e322c6f031abfca32940fd343cda46"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a22e322c6f031abfca32940fd343cda46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (<a class="el" href="classgrape_1_1OutArchive.html">OutArchive</a> &amp;out_archive, ska::flat_hash_map&lt; T1, T2 &gt; &amp;m)</td></tr>
<tr class="separator:a22e322c6f031abfca32940fd343cda46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0019b4cd3da789ec3f743f7439433431"><td class="memItemLeft" align="right" valign="top"><a id="a0019b4cd3da789ec3f743f7439433431"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="structgrape_1_1EmptyType.html">EmptyType</a>)</td></tr>
<tr class="separator:a0019b4cd3da789ec3f743f7439433431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbde8d523b6210b93a7fbcd9af90965b"><td class="memItemLeft" align="right" valign="top"><a id="afbde8d523b6210b93a7fbcd9af90965b"></a>
std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (std::istream &amp;in, <a class="el" href="structgrape_1_1EmptyType.html">EmptyType</a>)</td></tr>
<tr class="separator:afbde8d523b6210b93a7fbcd9af90965b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057729c6ba5e4b206a52091035bc3738"><td class="memTemplParams" colspan="2"><a id="a057729c6ba5e4b206a52091035bc3738"></a>
template&lt;typename E &gt; </td></tr>
<tr class="memitem:a057729c6ba5e4b206a52091035bc3738"><td class="memTemplItemLeft" align="right" valign="top">constexpr enable_enum_t&lt; E &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>underlying_value</b> (E e) noexcept</td></tr>
<tr class="separator:a057729c6ba5e4b206a52091035bc3738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1c930bd84918f0e59b35550be320db"><td class="memTemplParams" colspan="2"><a id="a6f1c930bd84918f0e59b35550be320db"></a>
template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:a6f1c930bd84918f0e59b35550be320db"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; std::is_enum&lt; E &gt;::value &amp;&amp;std::is_integral&lt; T &gt;::value, E &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_enum</b> (T value) noexcept</td></tr>
<tr class="separator:a6f1c930bd84918f0e59b35550be320db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b8578b668a2a57e14a487c83598419a"><td class="memTemplParams" colspan="2"><a id="a7b8578b668a2a57e14a487c83598419a"></a>
template&lt;typename APP_T , typename GRAPH_T &gt; </td></tr>
<tr class="memitem:a7b8578b668a2a57e14a487c83598419a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>check_load_strategy_compatible</b> ()</td></tr>
<tr class="separator:a7b8578b668a2a57e14a487c83598419a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed74d045e64131c98e7d1f4cd19ebdc"><td class="memTemplParams" colspan="2"><a id="a2ed74d045e64131c98e7d1f4cd19ebdc"></a>
template&lt;typename APP_T , typename GRAPH_T &gt; </td></tr>
<tr class="memitem:a2ed74d045e64131c98e7d1f4cd19ebdc"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>check_message_strategy_valid</b> ()</td></tr>
<tr class="separator:a2ed74d045e64131c98e7d1f4cd19ebdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8336cf38671c1b2e3d45f18498069197"><td class="memTemplParams" colspan="2"><a id="a8336cf38671c1b2e3d45f18498069197"></a>
template&lt;typename APP_T , typename GRAPH_T &gt; </td></tr>
<tr class="memitem:a8336cf38671c1b2e3d45f18498069197"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>check_app_fragment_consistency</b> ()</td></tr>
<tr class="separator:a8336cf38671c1b2e3d45f18498069197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef523007609c9943283d72cb16660ace"><td class="memItemLeft" align="right" valign="top"><a id="aef523007609c9943283d72cb16660ace"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>GetCurrentTime</b> ()</td></tr>
<tr class="separator:aef523007609c9943283d72cb16660ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d388d75943eedcc74c103e90b72029"><td class="memItemLeft" align="right" valign="top"><a id="ac3d388d75943eedcc74c103e90b72029"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>GetMemoryUsage</b> (const int proc_id, const std::string &amp;info)</td></tr>
<tr class="separator:ac3d388d75943eedcc74c103e90b72029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9afdceec613fbdfd5d4af9b6d45492ea"><td class="memTemplParams" colspan="2"><a id="a9afdceec613fbdfd5d4af9b6d45492ea"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a9afdceec613fbdfd5d4af9b6d45492ea"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>StringFormat</b> (const std::string &amp;format, Args... args)</td></tr>
<tr class="separator:a9afdceec613fbdfd5d4af9b6d45492ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae521c713545b0375558f7492680800c8"><td class="memItemLeft" align="right" valign="top"><a id="ae521c713545b0375558f7492680800c8"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegrape.html#ae521c713545b0375558f7492680800c8">GetResultFilename</a> (const std::string &amp;prefix, const fid_t fid)</td></tr>
<tr class="memdesc:ae521c713545b0375558f7492680800c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the formatted result filename. <br /></td></tr>
<tr class="separator:ae521c713545b0375558f7492680800c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae862702300407ca67c9779f5f1d35081"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae862702300407ca67c9779f5f1d35081"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegrape.html#ae862702300407ca67c9779f5f1d35081">DistinctSort</a> (std::vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="memdesc:ae862702300407ca67c9779f5f1d35081"><td class="mdescLeft">&#160;</td><td class="mdescRight">sort the target vector and eliminate the duplicated elements.  <a href="#ae862702300407ca67c9779f5f1d35081">More...</a><br /></td></tr>
<tr class="separator:ae862702300407ca67c9779f5f1d35081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e16a262c532c450a11b6b191012b44"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a59e16a262c532c450a11b6b191012b44"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegrape.html#a59e16a262c532c450a11b6b191012b44">atomic_compare_and_swap</a> (T &amp;val, T old_val, T new_val)</td></tr>
<tr class="memdesc:a59e16a262c532c450a11b6b191012b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic compare and swap operation. Equavalent to:  <a href="#a59e16a262c532c450a11b6b191012b44">More...</a><br /></td></tr>
<tr class="separator:a59e16a262c532c450a11b6b191012b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070931a4775de6d9046c54ddf01d0ca9"><td class="memTemplParams" colspan="2"><a id="a070931a4775de6d9046c54ddf01d0ca9"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a070931a4775de6d9046c54ddf01d0ca9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>atomic_compare_and_swap</b> (float &amp;val, float old_val, float new_val)</td></tr>
<tr class="separator:a070931a4775de6d9046c54ddf01d0ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9fde54bc98d169d2c107dab6f0d09e2"><td class="memTemplParams" colspan="2"><a id="ae9fde54bc98d169d2c107dab6f0d09e2"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae9fde54bc98d169d2c107dab6f0d09e2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>atomic_compare_and_swap</b> (double &amp;val, double old_val, double new_val)</td></tr>
<tr class="separator:ae9fde54bc98d169d2c107dab6f0d09e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4171c6f370c8f38744232ab83f8c125b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4171c6f370c8f38744232ab83f8c125b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegrape.html#a4171c6f370c8f38744232ab83f8c125b">atomic_min</a> (T &amp;a, T b)</td></tr>
<tr class="memdesc:a4171c6f370c8f38744232ab83f8c125b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic compare and store the minimum value. Equavalent to:  <a href="#a4171c6f370c8f38744232ab83f8c125b">More...</a><br /></td></tr>
<tr class="separator:a4171c6f370c8f38744232ab83f8c125b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73780b29e49190720decbb46bf5e0ba2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a73780b29e49190720decbb46bf5e0ba2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegrape.html#a73780b29e49190720decbb46bf5e0ba2">atomic_add</a> (T &amp;a, T b)</td></tr>
<tr class="memdesc:a73780b29e49190720decbb46bf5e0ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic add a value. Equavalent to:  <a href="#a73780b29e49190720decbb46bf5e0ba2">More...</a><br /></td></tr>
<tr class="separator:a73780b29e49190720decbb46bf5e0ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a5904bec09e714ace15d5667a22a1a"><td class="memTemplParams" colspan="2"><a id="aa3a5904bec09e714ace15d5667a22a1a"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aa3a5904bec09e714ace15d5667a22a1a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>atomic_add</b> (float &amp;a, float b)</td></tr>
<tr class="separator:aa3a5904bec09e714ace15d5667a22a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ffefdf6107b557d4aa026dd25792f2"><td class="memTemplParams" colspan="2"><a id="a87ffefdf6107b557d4aa026dd25792f2"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a87ffefdf6107b557d4aa026dd25792f2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>atomic_add</b> (double &amp;a, double b)</td></tr>
<tr class="separator:a87ffefdf6107b557d4aa026dd25792f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437d42c2cf58e0897b70760add231ba9"><td class="memTemplParams" colspan="2"><a id="a437d42c2cf58e0897b70760add231ba9"></a>
template&lt;typename _Tp1 , typename _Tp2 &gt; </td></tr>
<tr class="memitem:a437d42c2cf58e0897b70760add231ba9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classgrape_1_1DefaultAllocator.html">DefaultAllocator</a>&lt; _Tp1 &gt; &amp;, const <a class="el" href="classgrape_1_1DefaultAllocator.html">DefaultAllocator</a>&lt; _Tp2 &gt; &amp;)</td></tr>
<tr class="separator:a437d42c2cf58e0897b70760add231ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e13205849373b54a53935e37bfdb943"><td class="memTemplParams" colspan="2"><a id="a3e13205849373b54a53935e37bfdb943"></a>
template&lt;typename _Tp1 , typename _Tp2 &gt; </td></tr>
<tr class="memitem:a3e13205849373b54a53935e37bfdb943"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classgrape_1_1DefaultAllocator.html">DefaultAllocator</a>&lt; _Tp1 &gt; &amp;, const <a class="el" href="classgrape_1_1DefaultAllocator.html">DefaultAllocator</a>&lt; _Tp2 &gt; &amp;)</td></tr>
<tr class="separator:a3e13205849373b54a53935e37bfdb943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37690118e15c5f3b7ffed29f6ecfdfc2"><td class="memTemplParams" colspan="2"><a id="a37690118e15c5f3b7ffed29f6ecfdfc2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a37690118e15c5f3b7ffed29f6ecfdfc2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (<a class="el" href="classgrape_1_1Vertex.html">Vertex</a>&lt; T &gt; const &amp;lhs, <a class="el" href="classgrape_1_1Vertex.html">Vertex</a>&lt; T &gt; const &amp;rhs)</td></tr>
<tr class="separator:a37690118e15c5f3b7ffed29f6ecfdfc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b15c3ec4b0b0604cc7b5a50971b35f"><td class="memTemplParams" colspan="2"><a id="ab6b15c3ec4b0b0604cc7b5a50971b35f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab6b15c3ec4b0b0604cc7b5a50971b35f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="classgrape_1_1Vertex.html">Vertex</a>&lt; T &gt; const &amp;lhs, <a class="el" href="classgrape_1_1Vertex.html">Vertex</a>&lt; T &gt; const &amp;rhs)</td></tr>
<tr class="separator:ab6b15c3ec4b0b0604cc7b5a50971b35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab4e066655e492d006b082100c3434847"><td class="memItemLeft" align="right" valign="top"><a id="ab4e066655e492d006b082100c3434847"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>kCoordinatorRank</b> = 0</td></tr>
<tr class="separator:ab4e066655e492d006b082100c3434847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b726cc6b76ac83f67aa9bd2cf5d594f"><td class="memItemLeft" align="right" valign="top"><a id="a6b726cc6b76ac83f67aa9bd2cf5d594f"></a>
const char&#160;</td><td class="memItemRight" valign="bottom"><b>kSerializationVertexMapFilename</b> [] = &quot;vertex_map.s&quot;</td></tr>
<tr class="separator:a6b726cc6b76ac83f67aa9bd2cf5d594f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff7a444d82d0911a3e9b113d1d2698f"><td class="memItemLeft" align="right" valign="top"><a id="acff7a444d82d0911a3e9b113d1d2698f"></a>
const char&#160;</td><td class="memItemRight" valign="bottom"><b>kSerializationFilenameFormat</b> [] = &quot;%s/frag_%d.s&quot;</td></tr>
<tr class="separator:acff7a444d82d0911a3e9b113d1d2698f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A Worker manages the computation cycle. <a class="el" href="classgrape_1_1ParallelWorker.html">ParallelWorker</a> is a kind of worker for apps derived from <a class="el" href="classgrape_1_1ParallelAppBase.html" title="ParallelAppBase is a base class for parallel apps. Users can process messages in a more flexible way ...">ParallelAppBase</a>. </p>
<p>Copyright 2020 Alibaba Group Holding Limited.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.apache.org/licenses/LICENSE-2.0
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>NOLINT(legal/copyright)</p>
<p>The file utils/gcontainer.h is based on code from libcxx,</p>
<p><a href="https://github.com/llvm-mirror/libcxx/blob/master/include/vector">https://github.com/llvm-mirror/libcxx/blob/master/include/vector</a></p>
<p>which has the following license:</p>
<p>-*- C++ -*- ===---------------------------&mdash; vector -----------------------------&mdash;===//</p>
<p>Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions. See <a href="https://llvm.org/LICENSE.txt">https://llvm.org/LICENSE.txt</a> for license information. SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</p>
<p>===-------------------------------------------------------------------&mdash;===// </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ad40e01301e786e48610a7570c132d93c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40e01301e786e48610a7570c132d93c">&#9670;&nbsp;</a></span>MessageStrategy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacegrape.html#ad40e01301e786e48610a7570c132d93c">grape::MessageStrategy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>MessageStrategy specifies the method of message passing between fragments. </p>
<p>Assume in an edgecut distributed graph, we have an edge a-&gt;b, with vertex a on fragment_1 and b on fragment_2, and an edge a&lt;-c with c on f_2.</p>
<p>for fragment_1, a is an inner_vertex and b', c' is outer_vertexs. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad40e01301e786e48610a7570c132d93ca27407bfcdec900987bb5a513e6634604"></a>kAlongIncomingEdgeToOuterVertex&#160;</td><td class="fielddoc"><p>from a to b; </p>
</td></tr>
<tr><td class="fieldname"><a id="ad40e01301e786e48610a7570c132d93caa79427df483e13f39252db6cf07e6d6b"></a>kAlongEdgeToOuterVertex&#160;</td><td class="fielddoc"><p>from c to a; </p>
</td></tr>
<tr><td class="fieldname"><a id="ad40e01301e786e48610a7570c132d93cad6fbc9535d3da66fc48363c13f8c50d2"></a>kSyncOnOuterVertex&#160;</td><td class="fielddoc"><p>from a to b, a to c; </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a73780b29e49190720decbb46bf5e0ba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73780b29e49190720decbb46bf5e0ba2">&#9670;&nbsp;</a></span>atomic_add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void grape::atomic_add </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomic add a value. Equavalent to: </p>
<div class="fragment"><div class="line">a += b;</div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Object to process. </td></tr>
    <tr><td class="paramname">b</td><td>Value to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59e16a262c532c450a11b6b191012b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e16a262c532c450a11b6b191012b44">&#9670;&nbsp;</a></span>atomic_compare_and_swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool grape::atomic_compare_and_swap </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>old_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>new_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomic compare and swap operation. Equavalent to: </p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (val == old_val) {</div><div class="line">  val = new_val;</div><div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">} <span class="keywordflow">else</span> {</div><div class="line">  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">}</div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Object to process. </td></tr>
    <tr><td class="paramname">old_val</td><td>Old value to check. </td></tr>
    <tr><td class="paramname">new_val</td><td>New value to assign.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the value has been changed. </dd></dl>

</div>
</div>
<a id="a4171c6f370c8f38744232ab83f8c125b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4171c6f370c8f38744232ab83f8c125b">&#9670;&nbsp;</a></span>atomic_min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool grape::atomic_min </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomic compare and store the minimum value. Equavalent to: </p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (a &gt; b) {</div><div class="line">  a = b;</div><div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">} <span class="keywordflow">else</span> {</div><div class="line">  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">}</div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Object to process. </td></tr>
    <tr><td class="paramname">b</td><td>Value to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the value has been changed. </dd></dl>

</div>
</div>
<a id="ae862702300407ca67c9779f5f1d35081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae862702300407ca67c9779f5f1d35081">&#9670;&nbsp;</a></span>DistinctSort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void grape::DistinctSort </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sort the target vector and eliminate the duplicated elements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>to be sorted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
